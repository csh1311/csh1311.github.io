<!DOCTYPE html>

<html class="article-header-style-default">
<head>
	
	<title>java - cc</title>
	<meta charset="utf-8">
	
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	
	<meta name="description" content="–## 												JAVA java之父—高斯林 Java的发展可以分为以下几个阶段：  1995年：Java语言的诞生。  1996年：Java 1.0版本的发布。  1997年：Java 1.1版本的发布，新增了事件处理模型等功能。  1999年：Java 2 Platform Standard Edition 1.2版本的发布，支持动态Web内容。  2002年：Java 2">
<meta property="og:type" content="article">
<meta property="og:title" content="java">
<meta property="og:url" content="http://example.com/2022/12/16/JAVA/index.html">
<meta property="og:site_name" content="cc">
<meta property="og:description" content="–## 												JAVA java之父—高斯林 Java的发展可以分为以下几个阶段：  1995年：Java语言的诞生。  1996年：Java 1.0版本的发布。  1997年：Java 1.1版本的发布，新增了事件处理模型等功能。  1999年：Java 2 Platform Standard Edition 1.2版本的发布，支持动态Web内容。  2002年：Java 2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220919165559479.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902133323410.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902162900225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902163809082.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902165249568.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902165249568.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902171840717.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902172119284.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902210944199.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902211057405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902211724508.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902220113515.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904100155619.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904100217142.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904110844634.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904111831605.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904111856074.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904162404297.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145255890.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145634099.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145839923.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907231629383.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220911173759076.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220912094526173.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220912153212668.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220914224011897.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220918172005955.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220919214226833.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220923130744244.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924144225531.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924150106666.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924165212609.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220929215914294.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003172048287.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003191448309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003191404657.png">
<meta property="article:published_time" content="2022-12-15T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-31T04:08:49.096Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220919165559479.png">

	<meta name="theme-color" content="#5e72e4">
	<meta name="theme-color-rgb" content="94,114,228">
	<meta name="theme-color-origin" content="#5e72e4">
	<meta name="argon-enable-custom-theme-color" content="true">
	<meta name="theme-card-radius" content="4">
	<meta name="theme-version" content="1.0.2">
	<link rel="icon" href="/assets/img/favicon.ico" type="image/x-icon">
	<link rel="shortcut icon" href="/assets/img/favicon.ico" type="image/x-icon">

	
<link rel="stylesheet" href="/assets/argon_css_merged.css">

	
<link rel="stylesheet" href="/style.css">

	
<link rel="stylesheet" href="//fonts.loli.net/css?family=Open+Sans:300,400,600,700|Noto+Serif+SC:300,600&display=swap.css">

	
<script src="/assets/argon_js_merged.js"></script>

	
<script src="/assets/js/argon.min.js"></script>

	
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


	
		
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

		
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

	

	<script>
		var argonConfig = {
			language: "zh_CN",
			
				zoomify: {
					duration: 200,
					easing: "cubic-bezier(0.4,0,0,1)",
					scale: 0.9
				},
			
			pangu: "false",
			
				lazyload: {
					threshold: 800,
					effect: "fadeIn"
				},
			
			disable_pjax: false,
			headroom: false
		}
	</script>
	<script>
		var darkmodeAutoSwitch = "false";
		function setDarkmode(enable){
			if (enable == true){
				$("html").addClass("darkmode");
			}else{
				$("html").removeClass("darkmode");
			}
			$(window).trigger("scroll");
		}
		function toggleDarkmode(){
			if ($("html").hasClass("darkmode")){
				setDarkmode(false);
				sessionStorage.setItem("Argon_Enable_Dark_Mode", "false");
			}else{
				setDarkmode(true);
				sessionStorage.setItem("Argon_Enable_Dark_Mode", "true");
			}
		}
		if (sessionStorage.getItem("Argon_Enable_Dark_Mode") == "true"){
			setDarkmode(true);
		}
		function toggleDarkmodeByPrefersColorScheme(media){
			if (sessionStorage.getItem('Argon_Enable_Dark_Mode') == "false" || sessionStorage.getItem('Argon_Enable_Dark_Mode') == "true"){
				return;
			}
			if (media.matches){
				setDarkmode(true);
			}else{
				setDarkmode(false);
			}
		}
		function toggleDarkmodeByTime(){
			if (sessionStorage.getItem('Argon_Enable_Dark_Mode') == "false" || sessionStorage.getItem('Argon_Enable_Dark_Mode') == "true"){
				return;
			}
			let hour = new Date().getHours();
			if (hour < 7 || hour >= 22){
				setDarkmode(true);
			}else{
				setDarkmode(false);
			}
		}
		if (darkmodeAutoSwitch == 'system'){
			var darkmodeMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
			darkmodeMediaQuery.addListener(toggleDarkmodeByPrefersColorScheme);
			toggleDarkmodeByPrefersColorScheme(darkmodeMediaQuery);
		}
		if (darkmodeAutoSwitch == 'time'){
			toggleDarkmodeByTime();
		}
		if (darkmodeAutoSwitch == 'alwayson'){
			setDarkmode(true);
		}

		function toggleAmoledDarkMode(){
			$("html").toggleClass("amoled-dark");
			if ($("html").hasClass("amoled-dark")){
				localStorage.setItem("Argon_Enable_Amoled_Dark_Mode", "true");
			}else{
				localStorage.setItem("Argon_Enable_Amoled_Dark_Mode", "false");
			}
		}
		if (localStorage.getItem("Argon_Enable_Amoled_Dark_Mode") == "true"){
			$("html").addClass("amoled-dark");
		}else if (localStorage.getItem("Argon_Enable_Amoled_Dark_Mode") == "false"){
			$("html").removeClass("amoled-dark");
		}
	</script>
	<script>
		if (navigator.userAgent.indexOf("Safari") !== -1 && navigator.userAgent.indexOf("Chrome") === -1){
			$("html").addClass("using-safari");
		}
	</script>

	
		
<script src="/assets/vendor/smoothscroll/smoothscroll1.js"></script>

	
<meta name="generator" content="Hexo 6.3.0"></head>



<style id="themecolor_css">
	
	:root{
		--themecolor: #5e72e4;
		--themecolor-dark0: #5368E2;
		--themecolor-dark: #485FE0;
		--themecolor-dark2: #324CDD;
		--themecolor-dark3: #233DD2;
		--themecolor-light: #8A98EB;
		--themecolor-rgbstr: 94,114,228;
		--themecolor-gradient: linear-gradient(150deg,var(--themecolor-light) 15%, var(--themecolor) 70%, var(--themecolor-dark0) 94%);

	}
</style>
<style id="theme_cardradius_css">
	:root{
		--card-radius: 4px;
	}
</style>

<body>
<div id="toolbar">
	<header class="header-global">
		<nav id="navbar-main" class="navbar navbar-main navbar-expand-lg navbar-transparent navbar-light bg-primary headroom--not-bottom headroom--not-top headroom--pinned">
			<div class="container">
				
				<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar_global" aria-controls="navbar_global" aria-expanded="false" aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>
				<a class="navbar-brand" href="/">ccsh</a>
				<div class="navbar-collapse collapse" id="navbar_global">
					<div class="navbar-collapse-header">
						<div class="row">
							<div class="col-6 collapse-brand"></div>
							<div class="col-6 collapse-close">
								<button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar_global" aria-controls="navbar_global" aria-expanded="false" aria-label="Toggle navigation">
									<span></span>
									<span></span>
								</button>
							</div>
						</div>
					</div>
					<ul id="navbar_search_btn_mobile" class="navbar-nav align-items-lg-center ml-lg-auto">
						<li class="nav-item" data-toggle="modal" data-target="#argon_search_modal" style="padding-left: 5px;">
							<a class="nav-link nav-link-icon">
								<i class="fa fa-search"></i>
								<span class="nav-link-inner--text d-lg-none">搜索</span>
							</a>
						</li>
					</ul>
					
							<ul class='navbar-nav navbar-nav-hover align-items-lg-center'>
								
										<li class='nav-item'>
											<a href='/' class='nav-link' >
												<i class='ni ni-book-bookmark d-lg-none'></i>
												<span class='nav-link-inner--text'>首页</span>
											</a>
											
										</li>
									
							</ul>
						
					<ul class="navbar-nav align-items-lg-center ml-lg-auto">
						<li class="nav-item" data-toggle="modal" data-target="#argon_search_modal" id="navbar_search_btn_pc">
							<a class="nav-link nav-link-icon">
								<i class="fa fa-search"></i>
								<span class="nav-link-inner--text d-lg-none">搜索</span>
							</a>
						</li>
					</ul>
				</div>
				
				<div id="navbar_menu_mask" data-toggle="collapse" data-target="#navbar_global"></div>
			</div>
		</nav>
	</header>
</div>
<div class="modal fade" id="argon_search_modal" tabindex="-1" role="dialog" aria-labelledby="" aria-hidden="true">
	<div class="modal-dialog modal-dialog-centered modal-lg" role="document">
		<div class="modal-content">
			<div class="modal-header">
				<h5 class="modal-title">搜索</h5>
				<button type="button" class="close" data-dismiss="modal" aria-label="Close">
					<span aria-hidden="true">&times;</span>
				</button>
			</div>
			<div class="modal-body">
				<!-- TODO -->
<div class="form-group mb-3">
	<div class="input-group input-group-alternative">
		<div class="input-group-prepend">
			<span class="input-group-text"><i class="fa fa-search"></i></span>
		</div>
		<input id="local-search-input" class="form-control" placeholder="搜索什么..." type="text"  autocomplete="off" data-search.path="search.xml" data-config.root="/">
	</div>
	<div id="local-search-result"></div>
</div>

			</div>
		</div>
	</div>
</div>
<!--Banner-->
<section id="banner" class="banner section section-lg section-shaped">
	<div class="shape shape-style-1 shape-primary">
		<span></span>
		<span></span>
		<span></span>
		<span></span>
		<span></span>
		<span></span>
		<span></span>
		<span></span>
		<span></span>
	</div>

	
	<div id="banner_container" class="banner-container container text-center">
		
			<div class="banner-title text-white"><span class="banner-title-inner">ccsh</span>
		
		</div>
	</div>
	
		<style>
			section.banner{
				background-image: url(/assets/img/banner.jpg) !important;
			}
		</style>
	
</section>


	<style>
		#content:before {
			content: '';
			display: block;
			position: fixed;
			left: 0;
			right: 0;
			top: 0;
			bottom: 0;
			z-index: -2;
			background: url(/assets/img/banner.jpg);
			background-position: center;
			background-size: cover;
			background-repeat: no-repeat;
			opacity: 1;
			transition: opacity .5s ease;
		}
		html.darkmode #content:before{
			filter: brightness(0.65);
		}
		
			#content:after {
				content: '';
				display: block;
				position: fixed;
				left: 0;
				right: 0;
				top: 0;
				bottom: 0;
				z-index: -2;
				background: url(/assets/img/banner.jpg);
				background-position: center;
				background-size: cover;
				background-repeat: no-repeat;
				opacity: 0;
				transition: opacity .5s ease;
			}
			html.darkmode #content:after {
				opacity: 1;
			}
			html.darkmode #content:before {
				opacity: 0;
			}
		
		
			#banner, #banner .shape {
				background: transparent !important;
			}
		
	</style>




<div id="float_action_buttons" class="float-action-buttons fabtns-unloaded">
	<button id="fabtn_toggle_sides" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-hidden="true" tooltip-move-to-left="移至左侧" tooltip-move-to-right="移至右侧">
		<span class="btn-inner--icon fabtn-show-on-right"><i class="fa fa-caret-left"></i></span>
		<span class="btn-inner--icon fabtn-show-on-left"><i class="fa fa-caret-right"></i></span>
	</button>
	<button id="fabtn_back_to_top" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-label="Back To Top" tooltip="回到顶部">
		<span class="btn-inner--icon"><i class="fa fa-angle-up"></i></span>
	</button>
	<button id="fabtn_go_to_comment" class="btn btn-icon btn-neutral fabtn shadow-sm d-none" type="button" <-% theme.fab_show_gotocomment_button ? "" : "style='display: none;'"  aria-label="Comment" tooltip="评论">
		<span class="btn-inner--icon"><i class="fa fa-comment-o"></i></span>
	</button>
	<button id="fabtn_toggle_darkmode" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" <-% theme.fab_show_darkmode_button ? "" : "style='display: none;'"  aria-label="Toggle Darkmode" tooltip-darkmode="夜间模式" tooltip-blackmode="暗黑模式" tooltip-lightmode="日间模式">
		<span class="btn-inner--icon"><i class="fa fa-moon-o"></i><i class='fa fa-lightbulb-o'></i></span>
	</button>
	<button id="fabtn_toggle_blog_settings_popup" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" <-% theme.fab_show_settings_button ? "" : "style='display: none;'"  aria-label="Open Blog Settings Menu" tooltip="设置">
		<span class="btn-inner--icon"><i class="fa fa-cog"></i></span>
	</button>
	<div id="fabtn_blog_settings_popup" class="card shadow-sm" style="opacity: 0;" aria-hidden="true">
		<div id="close_blog_settings"><i class="fa fa-close"></i></div>
		<div class="blog-setting-item mt-3">
			<div style="transform: translateY(-4px);"><div id="blog_setting_toggle_darkmode_and_amoledarkmode" tooltip-switch-to-darkmode="切换到夜间模式" tooltip-switch-to-blackmode="切换到暗黑模式"><span>夜间模式</span><span>暗黑模式</span></div></div>
			<div style="flex: 1;"></div>
			<label id="blog_setting_darkmode_switch" class="custom-toggle">
				<span class="custom-toggle-slider rounded-circle"></span>
			</label>
		</div>
		<div class="blog-setting-item mt-3">
			<div style="flex: 1;">字体</div>
			<div>
				<button id="blog_setting_font_sans_serif" type="button" class="blog-setting-font btn btn-outline-primary blog-setting-selector-left">Sans Serif</button><button id="blog_setting_font_serif" type="button" class="blog-setting-font btn btn-outline-primary blog-setting-selector-right">Serif</button>
			</div>
		</div>
		<div class="blog-setting-item mt-3">
			<div style="flex: 1;">阴影</div>
			<div>
				<button id="blog_setting_shadow_small" type="button" class="blog-setting-shadow btn btn-outline-primary blog-setting-selector-left">浅阴影</button><button id="blog_setting_shadow_big" type="button" class="blog-setting-shadow btn btn-outline-primary blog-setting-selector-right">深阴影</button>
			</div>
		</div>
		<div class="blog-setting-item mt-3 mb-3">
			<div style="flex: 1;">滤镜</div>
			<div id="blog_setting_filters" class="ml-3">
				<button id="blog_setting_filter_off" type="button" class="blog-setting-filter-btn ml-0" filter-name="off">关闭</button>
				<button id="blog_setting_filter_sunset" type="button" class="blog-setting-filter-btn" filter-name="sunset">日落</button>
				<button id="blog_setting_filter_darkness" type="button" class="blog-setting-filter-btn" filter-name="darkness">暗化</button>
				<button id="blog_setting_filter_grayscale" type="button" class="blog-setting-filter-btn" filter-name="grayscale">灰度</button>
			</div>
		</div>
		<div class="blog-setting-item mb-3">
			<div id="blog_setting_card_radius_to_default" style="cursor: pointer;" tooltip="恢复默认">圆角</div>
			<div style="flex: 1;margin-left: 20px;margin-right: 8px;transform: translateY(2px);">
				<div id="blog_setting_card_radius"></div>
			</div>
		</div>
		
			<div class="blog-setting-item mt-1 mb-3">
				<div style="flex: 1;">主题色</div>
				<div id="theme-color-picker" class="ml-3"></div>
			</div>
		
	</div>
	<button id="fabtn_open_sidebar" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-label="Open Sidebar Menu" tooltip="菜单">
		<span class="btn-inner--icon"><i class="fa fa-bars"></i></span>
	</button>
	<button id="fabtn_reading_progress" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-hidden="true" tooltip="阅读进度">
		<div id="fabtn_reading_progress_bar" style="width: 0%;"></div>
		<span id="fabtn_reading_progress_details">0%</span>
	</button>
</div>

<div id="content" class="site-content">









<div class="page-information-card-container">
	
</div>

<div id="sidebar_mask"></div>
<aside id="leftbar" class="leftbar widget-area" role="complementary">
		
		<div id="leftbar_part1" class="widget widget_search card bg-white shadow-sm border-0">
			<div class="leftbar-banner card-body">
				<span class="leftbar-banner-title text-white">ccsh</span>
				
				
			</div>
			
			
				<ul id='leftbar_part1_menu' class='leftbar-menu'>
					<li class='leftbar-menu-item'><a href='/'>首页</a></li><li class='leftbar-menu-item'><a href='/archives'>归档</a></li>
				</ul>
			
			<div class="card-body text-center leftbar-search-button">
				<button id="leftbar_search" class="btn btn-secondary btn-lg active btn-sm btn-block border-0" role="button" data-toggle="modal" data-target="#argon_search_modal" >
					<i class="menu-item-icon fa fa-search mr-0"></i> 搜索
				</button>
			</div>
		</div>
		<div id="leftbar_part2" class="widget widget_search card bg-white shadow-sm border-0">
			<div id="leftbar_part2_inner" class="card-body">
				
				<div class="nav-wrapper" style="padding-top: 5px;">
	                <ul class="nav nav-pills nav-fill" role="tablist">
						
							<li class="nav-item sidebar-tab-switcher">
								<a class="active show" id="leftbar_tab_catalog_btn" data-toggle="tab" href="#leftbar_tab_catalog" role="tab" aria-controls="leftbar_tab_catalog" no-pjax>文章目录</a>
							</li>
						
						<li class="nav-item sidebar-tab-switcher">
							<a class="" id="leftbar_tab_overview_btn" data-toggle="tab" href="#leftbar_tab_overview" role="tab" aria-controls="leftbar_tab_overview" no-pjax>站点概览</a>
						</li>
	                </ul>
				</div>
				<div>
					<div class="tab-content" style="padding: 10px 10px 0 10px;">
						
							<div class="tab-pane fade active show" id="leftbar_tab_catalog" role="tabpanel" aria-labelledby="leftbar_tab_catalog_btn">
								<div id="leftbar_catalog"></div>
								<script type="text/javascript">
									$(function () {
										$(document).headIndex({
											articleWrapSelector: '#post_content',
											indexBoxSelector: '#leftbar_catalog',
											subItemBoxClass: "index-subItem-box",
											itemClass: "index-item",
											linkClass: "index-link",
											offset: 80,
										});
									})
								</script>
								
							</div>
						
						<div class="tab-pane fade text-center" id="leftbar_tab_overview" role="tabpanel" aria-labelledby="leftbar_tab_overview_btn">
							<img id="leftbar_overview_author_image" src="https://raw.githubusercontent.com/csh1311/blogImage/main/head.jpg" class="img-fluid rounded-circle shadow-sm" style="width: 100px;" alt="avatar">
							<h6 id="leftbar_overview_author_name">cc</h6>
							<nav class="site-state">
								<div class="site-state-item site-state-posts">
									<a href="/archives">
										<span class="site-state-item-count">9</span>
										<span class="site-state-item-name">文章</span>
									</a>
								</div>
								<div class="site-state-item site-state-categories">
									<a data-toggle="modal" data-target="#blog_categories">
										<span class="site-state-item-count">0</span>
										<span class="site-state-item-name">分类</span>
									</a>
								</div>      
								<div class="site-state-item site-state-tags">
									<a data-toggle="modal" data-target="#blog_tags">
										<span class="site-state-item-count">0</span>
										<span class="site-state-item-name">标签</span>
									</a>
								</div>
							</nav>
							
									<div class="site-author-links">
										
											<div class='site-author-links-item'>
												<a href="https://github.com/csh1311" rel='noopener' target='_blank'>GitHub</a>
											</div>
										
											<div class='site-author-links-item'>
												<a href="/" rel='noopener' target='_blank'>Telegram</a>
											</div>
										
									</div>
								
							
									<div class='site-friend-links'>
										<div class='site-friend-links-title'><i class='fa fa-fw fa-link'></i> Links</div>
										<ul class='site-friend-links-ul'>
											
										</ul>
									</div>
								
						</div>
					</div>
				</div>
			</div>
		</div>
</aside>
<div class="modal fade" id="blog_categories" tabindex="-1" role="dialog" aria-labelledby="" aria-hidden="true">
	<div class="modal-dialog modal-dialog-centered">
		<div class="modal-content">
			<div class="modal-header">
				<h5 class="modal-title">分类</h5>
				<button type="button" class="close" data-dismiss="modal" aria-label="Close">
					<span aria-hidden="true">&times;</span>
				</button>
			</div>
			<div class="modal-body">
				
			</div>
		</div>
	</div>
</div>
<div class="modal fade" id="blog_tags" tabindex="-1" role="dialog" aria-labelledby="" aria-hidden="true">
	<div class="modal-dialog modal-dialog-centered">
		<div class="modal-content">
			<div class="modal-header">
				<h5 class="modal-title">标签</h5>
				<button type="button" class="close" data-dismiss="modal" aria-label="Close">
					<span aria-hidden="true">&times;</span>
				</button>
			</div>
			<div class="modal-body">
				
			</div>
		</div>
	</div>
</div>


<div id="primary" class="content-area">
	<main id="main" class="site-main" role="main">
		
		
			
	<article class="post post-full card bg-white shadow-sm border-0 ">
	<header class="post-header text-center">
		
		<a class="post-title" href="/2022/12/16/JAVA/">java</a>
		<div class="post-meta">
			
						
						<div class="post-meta-detail post-meta-detail-time">
							<i class="fa fa-clock-o" aria-hidden="true"></i>
							<time title="发布于 2022-12-16 0:00:00 | 编辑于 2023-1-31 12:08:49">2022-12-16 0:00
							</time>
						</div>
					
						
							<div class="post-meta-devide">|</div>
						
						<div class="post-meta-detail post-meta-detail-words">
							<i class="fa fa fa-book" aria-hidden="true"></i>
							<span id="busuanzi_container_page_pv">
								阅读<span id="busuanzi_value_page_pv"></span>次
							</span>
						</div>
					
						
							<div class="post-meta-devide">|</div>
						
						<div class="post-meta-detail post-meta-detail-words">
							<i class="fa fa-file-word-o" aria-hidden="true"></i>
							14.2k 字
						</div>
					
						
							<div class="post-meta-devide">|</div>
						
						<div class="post-meta-detail post-meta-detail-readingtime">
							<i class="fa fa-hourglass-end" aria-hidden="true"></i>
							60 分钟
						</div>
					
		</div>
		
	</header>

	<div class="post-content" id="post_content">
		<p>–## 												JAVA</p>
<p>java之父—高斯林</p>
<p>Java的发展可以分为以下几个阶段：</p>
<ol>
<li><p>1995年：Java语言的诞生。</p>
</li>
<li><p>1996年：Java 1.0版本的发布。</p>
</li>
<li><p>1997年：Java 1.1版本的发布，新增了事件处理模型等功能。</p>
</li>
<li><p>1999年：Java 2 Platform Standard Edition 1.2版本的发布，支持动态Web内容。</p>
</li>
<li><p>2002年：Java 2 Platform Standard Edition 1.4版本的发布，引入了注解、NIO等新特性。</p>
</li>
<li><p>2004年：Java 5.0版本的发布，引入了泛型、可枚举类型等特性。</p>
</li>
<li><p>2006年：Java 6版本的发布，改进了XML处理、并行计算等方面。</p>
</li>
<li><p>2011年：Java 7版本的发布，增加了语言级别的支持。</p>
</li>
<li><p>2014年：Java 8版本的发布，引入了Lambda表达式、Streams API等新特性。</p>
</li>
<li><p>2018年：Java 10版本的发布，带来了更多的语言和性能改进。</p>
</li>
<li><p>JDK是什么？有哪些内容组成？</p>
<p>​           JDK是java开发工具包</p>
<ul>
<li>​	JVM虚拟机：java程序运行的地方</li>
<li>核心类库：java已经写好的东西，我们可以直接用。</li>
<li>开发工具：javac、java、jdb、jhat</li>
</ul>
</li>
<li><p>JRE是什么？有哪些内容组成？</p>
<p>JRE是java运行环境</p>
<p>JVM、核心类库、运行工具</p>
</li>
<li><p>JDk、JRE、JVM三者包含关系</p>
<ul>
<li>JDK包含JRE</li>
<li>JRE包含JVM</li>
</ul>
</li>
</ol>
<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul>
<li>在ACIIL表中字符’1’对应的数字是49，字符’0’对应的字符是48，这两个字符’1’-‘0’等于数字1</li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>隐式转换小结</p>
<ol>
<li><p>取值范围</p>
<p>byte&lt;short&lt;int&lt;long&lt;float&lt;double</p>
</li>
<li><p>什么时候转换</p>
<p>数据类型不一样，不能计算，需要转成一样的数据类型才可以计算</p>
</li>
<li><p>转换规则1：</p>
<p>取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算</p>
</li>
<li><p>转换规则2</p>
<p>byte short char 三种类型的数据在运算的时候，都会直接先提升到int，然后再进行运算</p>
</li>
</ol>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220919165559479.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220919165559479"></p>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>数组定义</p>
<ul>
<li>数据类型[]   数组名 &#x3D;  new 数据类型[]{元素1，元素2，元素3}</li>
<li>数据类型[]  数组名 &#x3D; {}</li>
</ul>
<p>例：</p>
<pre><code class="java">//        定义数组存储5个学生年龄
        int[] arr = &#123;15,17,16,13&#125;;
        int[] ar1 = new int[]&#123;15,17,16,13&#125;;
        System.out.println(arr);  //[I@1b6d3586
        System.out.println(ar1);  //[I@4554617c

        //扩展
        //解释数组的地址值  //[I@1b6d3586
        //[ : 表示当前是一个数组
        //I ： 表示当前数组里面的元素都是int类型
        //@ ： 表示一个间隔符。固定格式
        //1b6d3586：才是数组真正的地址。（十六进制）
        //平时会把整个叫做数组地址值
</code></pre>
</li>
<li><p>java内存分配</p>
<ul>
<li>java运行是虚拟机也会占用内存，但是为了更好的利用这块内存，虚拟机又分配了5个部分，每个部分都有它自己的作用</li>
</ul>
<p>​     <img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902133323410.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902133323410" style="zoom:67%;" /></p>

<ul>
<li>jdk7以前方法区和堆是连在一起的</li>
</ul>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902162900225.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902162900225" style="zoom:67%;" />


<ul>
<li><p>注意：从jdk8开始取消了方法区，新增了元空间。把原来方法区的多种功能进行拆分，有的功能放在队中有的功能放在元空间中</p>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902163809082.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902163809082" style="zoom:67%;" /></li>

</ul>
</li>
<li><ul>
<li>栈   方法运行使用的内存，比如main方法运行，进入栈内存中</li>
<li>堆   存储对象或数组，只要new来创建的都进入堆内存中</li>
<li>方法区   存储可以运行class文件</li>
<li>本地方法栈   jvm使用操作系统的功能是使用，与开发无关</li>
<li>寄存器  给cpu使用，与开发无关</li>
</ul>
</li>
<li><p>数组内存分配</p>
<ul>
<li><p>只要是new出来的一定是在堆里面开辟一个小空间</p>
</li>
<li><p>如歌new了多次，那么堆里就有多少个小空间，而且每个小空间都有各自的数据</p>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902165249568.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902165249568" style="zoom:67%;" />

</li>
<li><p>当两个数组指向同一个空间的，其中一个数组对空间数据中的值发生改变，那么其他数据再次访问的时候都是修改之后的结果</p>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902165249568.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902165249568" style="zoom:67%;" /></li>

</ul>
</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>什么是方法</p>
<p>方法是程序中最小的执行单元</p>
<ol>
<li><p>实际开发中，什么时候用到方法？</p>
<p>​	重复的代码，具有独立功能的代码可以抽到方法中</p>
</li>
<li><p>实际开发中，方法有什么好处</p>
</li>
</ol>
<p>​            提高代码的复用性</p>
<p>​			提高代码的维护</p>
</li>
<li><p>方法的格式</p>
<ul>
<li><p>最简单的方法定义</p>
<ul>
<li>方法的定义</li>
</ul>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902171840717.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902171840717" style="zoom:67%;" />


<ul>
<li><p>方法的调用</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902172119284.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902172119284"></p>

<pre><code class="java">package Day;

public class Day04 &#123;
    public static void main(String[] args) &#123;
        //方法的调用
        playGame();
        /**
         * 练习
         *定义一个方法，在方法中定义两个变量进行求和
         */
        sum();
    &#125;

    /**
     * 注意：定义方法是在main主方法外面，但是方法的调用在主方法里面
     */
    //定义一个方法
    public static void playGame()&#123;
        System.out.println(&quot;准备&quot;);
        System.out.println(&quot;确定&quot;);
        System.out.println(&quot;操作&quot;);
        System.out.println(&quot;结束&quot;);
    &#125;

    //定义一个求和的方法
    public  static  void sum()&#123;
        int a = 10;
        int b = 20;
        int result = a+b;
        System.out.println(result);
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>带参数的方法定义</p>
<ul>
<li><p>带参数方法的定义</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902210944199.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902210944199"></p>

</li>
<li><p>带参数方法发调用</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902211057405.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902211057405"></p>

</li>
</ul>
<pre><code>
</code></pre>
<ul>
<li><p>形参和实参</p>
<ul>
<li><p>形参：全称形式参数，是指方法定义中的参数</p>
</li>
<li><p>实参：全称实际参数，是指调用的参数</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902211724508.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902211724508"></p>

</li>
</ul>
<pre><code>    public static void main(String[] args) &#123;
        //调用求长方形的周长，将结果在方法中进行
        rectangle(5.5,6.5);

        //调用求圆的面积，将结果在方法中打印
        circle(4.0);
    &#125;
    
        //定义一个长方形周长方法
    public static void rectangle(double len,double width)&#123;
        double result = (len+width)*2;
        System.out.println(result);
    &#125;

    //定义一个求圆的面积
    public static void circle(double r)&#123;
        double S = 3.14*(r*r);
        System.out.println(S);
    &#125;
</code></pre>
</li>
</ul>
</li>
<li><p>带返回值的方法定义</p>
<ul>
<li><p>带返回值方法的定义</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902220113515.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220902220113515"></p>

</li>
<li><p>带返回值方法的调用</p>
</li>
</ul>
<pre><code>    public static void main(String[] args) &#123;
        //调用长方形面积
        double are = getAre(3.0, 4.0);
        double are1 = getAre(4.0, 3.0);
        if (are &gt; are1)&#123;
            System.out.println(&quot;第一个长方形面积大于第二个长方形面积&quot;);
        &#125;else &#123;
            System.out.println(&quot;第二个长方形面积大于第一个长方形面积&quot;);
        &#125;

    &#125;
    
    
    //定义一个求长方形面积的方法
    public  static double getAre(double len,double width)&#123;
        double res = len*width;
        return res;
    &#125;
</code></pre>
<ul>
<li>方法的注意事项<ul>
<li>方法不调用就不执行</li>
<li>方法与方法之间是平级关系，不能互相嵌套</li>
<li>方法的编写顺序和执行顺序无关，根据方法调用顺序有关</li>
<li>方法的返回值类型为void，表示该方法没有返回值，没有返回值的方法可以省略return语句不写。如果要编写编写return，后面不能跟具体的数据。</li>
<li>return语句下面，不能编写代码，因为永远执行不到，属于无效代码</li>
</ul>
</li>
<li>return关键字<ul>
<li>方法没有返回值：可以省略不写。如果书写，表示结束方法</li>
<li>方法有返回值：必须要写。表示结束方法和返回结果是</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方法的重载</p>
<ul>
<li><p>什么是方法的重载</p>
<ul>
<li>在同一个类中，定义了多个同名的方法，这些同名的方法具有同种的功能</li>
<li>每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系</li>
</ul>
<p>简单机：同一个类中，方法名相同参数不同的方法。与返回值无关</p>
<p>​				参数不同：个数不同、类型不同、顺序不同</p>
</li>
</ul>
</li>
<li><p>方法的内存</p>
<ul>
<li>方法调用的基本内存原理</li>
<li>方法传递基本数据类型原理<ul>
<li>基本数据类型：变量存储的都是真是数据<ul>
<li>整数类型</li>
<li>浮点数类型</li>
<li>布尔类型</li>
<li>字符类型</li>
</ul>
</li>
<li>引用数据类型：在栈内记录的是地址值，使用其他空间的数据<ul>
<li>除了上面基本数据类型都是</li>
</ul>
</li>
</ul>
</li>
<li>方法传递引用数据类型的内存原理</li>
</ul>
</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li><p>设计对象并使用</p>
<ul>
<li><p>类和对象： 必须先设计类才能获取对象</p>
<ul>
<li>类（设计图）:是对象共同特征的描述</li>
<li>对象：是真实存在的具体东西</li>
</ul>
</li>
<li><p>类的几个注意事项</p>
<ul>
<li>用来描述一类事物的类，专业叫做：javabean类。在javabean类中，是不写mian方法的。</li>
<li>在以前。编写mian方法的类，叫做测试类。我们可以在测试类中创建Javabean类对象并进行赋值调用。</li>
</ul>
</li>
<li><p>总结</p>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904100155619.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220904100155619" style="zoom:67%;" />


<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904100217142.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220904100217142" style="zoom:67%;" /></li>

</ul>
</li>
<li><p>封装</p>
<p>- </p>
</li>
<li><p>this关键字</p>
<ul>
<li>可以区别成员变量和局部变量</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>作用：<ul>
<li>创建对象的时候，由虚拟机自动调用，给成员变量进行初始化的。</li>
</ul>
</li>
<li>特点：<ul>
<li>方法名与类名相同，大小写也要一致</li>
<li>没有返回值类型，连void都没有</li>
<li>没有具体的返回值（不能由retrun带回结果的数据）</li>
</ul>
</li>
<li>构造方法有几种，各自的作用是什么。<ul>
<li>无参数构造方法：初始化对象是，成员变量的数据均采用默认值。</li>
<li>有参数构造方法：在初始对象时候，同时可以为对象进行赋值。</li>
</ul>
</li>
<li>执行时机<ul>
<li>创建对象的时候由虚拟机调用，不能手动调用构造方法</li>
<li>每创建一次对象，就会调用一次构造方法</li>
</ul>
</li>
<li>构造方法定义<ul>
<li>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</li>
<li>如果定义构造方法，系统将不再提供默认的构造方法</li>
</ul>
</li>
<li>构造方法的重载<ul>
<li>带参构造方法，和无参构造方法，两者方法名相同但是参数不同，这叫做构造方法的重载</li>
</ul>
</li>
<li>推荐的使用方式<ul>
<li>无论是否使用，都手动书写无参数构造的方法，和带全部参数的构造方法</li>
</ul>
</li>
<li>构造方法有哪些注意事项<ul>
<li>任何类定义出来，默认自带了无参数构造器，写不写都有。</li>
<li>一旦定义了有参数构造器，无参数构造器就没有了，此时就需要自己写无参数构造器了。</li>
<li>建议在任何时候都手动写上空参和带全部参数的构造方法</li>
</ul>
</li>
</ul>
</li>
<li><p>标准javaBean</p>
<ul>
<li>类名需要见名知意</li>
<li>成员变量使用private修饰</li>
<li>提供至少两个构造方法、<ul>
<li>无参构造方法</li>
<li>有参构造方法</li>
</ul>
</li>
<li>成员方法<ul>
<li>提供每一个成员变量对应的setXxx()&#x2F;getXxx()</li>
<li>如果还要其他行为，也需要写上</li>
</ul>
</li>
</ul>
</li>
<li><p>对象内存图</p>
<ul>
<li><p>一个对象的内存图</p>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904110844634.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220904110844634" style="zoom: 50%;" />

</li>
<li><p>多个对象的内存图</p>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904111831605.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220904111831605" style="zoom: 50%;" />

</li>
<li><p>两个引用指向同一个对象的内存图</p>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904111856074.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220904111856074" style="zoom:50%;" />

</li>
<li><p>this的内存图原理</p>
<ul>
<li>this的作用:区分局部变量和成员变量</li>
<li>this的本质：所在方法调用者的地址值</li>
</ul>
</li>
<li><p>基本数据类型和引用数据类型的区别</p>
</li>
<li><p>局部变量和成员变量的区别</p>
</li>
</ul>
</li>
<li><p>补充知识：成员变量、局部变量区别</p>
<ul>
<li>成员变量：类中方法外的变量</li>
<li>局部变量：类中方法内的变量</li>
</ul>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904162404297.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220904162404297"></p>

</li>
<li><p>修饰符</p>
<ul>
<li>private<ul>
<li>是一个权限修饰符</li>
<li>可以修饰成员（成员变量和成员方法）</li>
<li>被private修饰的成员只能在本类中才能访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>练习</p>
<pre><code class="java">package Day.dayMxdx;

/**
 * 定义一个长度为3的数组，数组存储1~3名学生对象作为初始化数据，学生对象的学号，姓名各不相同。
 * 学生属性：学号，姓名，年龄
 * 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一判断
 * 要求二：添加完毕之后遍历所有学生信息
 * 要求三：通过id删除，如果不存在，则提示删除失败
 * 要求四：删除后遍历所有学生信息
 * 要求五：查询数组id为“heima002”的学生，如果存在，则将他年龄+1；
 */
public class Student &#123;

    private String id;
    private String name;
    private int age;

    public Student() &#123;
    &#125;

    public Student(String id, String name, int age) &#123;
        this.id = id;
        this.name = name;
        this.age = age;
    &#125;

    public String getId() &#123;
        return id;
    &#125;

    public void setId(String id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;

//测试类

package Day.dayMxdx;

/**
 * 定义一个长度为3的数组，数组存储1~3名学生对象作为初始化数据，学生对象的学号，姓名各不相同。
 * 学生属性：学号，姓名，年龄
 * 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一判断
 * 要求二：添加完毕之后遍历所有学生信息
 * 要求三：通过id删除，如果不存在，则提示删除失败
 * 要求四：删除后遍历所有学生信息
 * 要求五：查询数组id为“heima002”的学生，如果存在，则将他年龄+1；
 */



public class StudentTest &#123;
    public static void main(String[] args) &#123;
        //定义一个长度为3的数组
        Student[] arr = new  Student[3];

        //定义对象
        Student s1 = new Student(&quot;001&quot;,&quot;小明&quot;,18);
        Student s2 = new Student(&quot;002&quot;,&quot;小东&quot;,20);
        Student s3 = new Student(&quot;003&quot;,&quot;小蔡&quot;,22);
        //数组存储1~3名学生对象作为初始化数据
        arr[0] = s1;
        arr[1] = s2;
        arr[2] = s3;

        //再次添加一个对象到数组里面
        Student s4 = new Student(&quot;004&quot;,&quot;小第&quot;,28);
//        调用判断方法
        Boolean flag = repetition(arr, s4.getId());
        if (flag)&#123;
            System.out.println(&quot;数组里面已经存在id，请重新跟换id在添加&quot;);
        &#125;else &#123;
            int count = getCount(arr);
            //如果相等则数组长度不够
            if (count==arr.length)&#123;
                //重新创建数组
                Student[] createArr = createArr(arr);
                createArr[count] = s4;
                for (int i = 0; i &lt; createArr.length; i++) &#123;
                    Student student = createArr[i];
                    System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge());
                &#125;
            &#125;else &#123;
                arr[count] = s4;
            &#125;
        &#125;
        //根据id删除
        int index = getId(arr, &quot;002&quot;);
        if (index == -1) &#123;
            System.out.println(&quot;数组没有这个id，删除失败&quot;);
        &#125;else&#123;
            Student[] students = deleteArray(arr,index);
            System.out.println(&quot;删除成功&quot;);
            for (int i = 0; i &lt; students.length; i++) &#123;
                Student student = students[i];
                System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge());
            &#125;
        &#125;
        //查询数组id为“heima002”的学生，如果存在，则将他年龄+1
        //根据id删除
        int indexs = getId(arr, &quot;003&quot;);
        if (indexs == -1) &#123;
            System.out.println(&quot;数组没有这个id&quot;);
        &#125;else&#123;
            Student student = arr[indexs];
            System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+(student.getAge()+1));
        &#125;

    &#125;
    //定义一个方法判断数组数据
    public static  int getCount(Student[] arr)&#123;
        int count = 0;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.println(arr[i]);
            if (arr[i]!=null)&#123;
                count++;
            &#125;
        &#125;
        return count;
    &#125;

    //定义一个方法，判断数组里面是否有重复的数据
    public static Boolean  repetition(Student[] arr, String id)&#123;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            Student student = arr[i];
            if (student.getId()==id)&#123;
                return true;
            &#125;
        &#125;
        return  false;
    &#125;
    
    //定义一个如果数组长度不够，重新创建数组，然后数组长度等于旧数组的长度+1
    public static  Student[]  createArr(Student[] arr)&#123;
        Student[] createArr = new Student[arr.length+1];
        for (int i = 0; i &lt; arr.length; i++) &#123;
            createArr[i] = arr[i];
        &#125;
        return createArr;
    &#125;

    //定义一个方法根据id查询出索引的位置
    public  static  int getId(Student[] arr, String id)&#123;
        int count = -1;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            Student s = arr[i];
            if (s.getId()==id)&#123;
                count = i;
                break;
            &#125;
        &#125;
        return count;
    &#125;

    //定义一个方法删除数组元素
    public static  Student[] deleteArray(Student[] arr,int index)&#123;
        Student[] newArray = new  Student[arr.length-1];
        for (int i = 0; i &lt; newArray.length; i++) &#123;
            if (index&lt;0 || index &gt; arr.length)&#123;
                System.out.println(&quot;数组越界&quot;);
            &#125;
            if (i&lt;index)&#123;
                newArray[i] = arr[i];
            &#125;else &#123;
                newArray[i] = arr[i+1];
            &#125;
        &#125;
        System.out.println(newArray.length);
        return  newArray;
    &#125;
&#125;

</code></pre>
<h4 id="API和API文档"><a href="#API和API文档" class="headerlink" title="API和API文档"></a>API和API文档</h4><ul>
<li><p>API文档：应用程序编程接口</p>
<ul>
<li>简单理解：API就是别人已经写好的东西，我们不需要自己编写，直接使用即可</li>
</ul>
</li>
<li><p>Java API：指的就是JDK中提供的各种功能的java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。</p>
</li>
<li><p>String</p>
<ul>
<li><p>字符串的内容是不会发生改变的，它的对象创建后不能被更改</p>
</li>
<li><p>创建String对象的两种方式</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145255890.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220907145255890"></p>

</li>
<li><p>String内存模型</p>
<ul>
<li><p>当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。</p>
<ul>
<li>不存在：创新的</li>
<li>存在：复用</li>
</ul>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145634099.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220907145634099"></p>

</li>
<li><p>当使用new创建赋值是</p>
<ul>
<li>每new一个就会在堆里面创建小空间，不会使用Strin Table(串池)，这样会大量的使用内存</li>
</ul>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145839923.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220907145839923"></p>

</li>
<li><p>字符串之间比较</p>
<ul>
<li><p>第一个方式创建和第二个方式new出来的用&#x3D;&#x3D;于比较是等于false，因为它们比较的是地址值</p>
<pre><code class="java">String name = &quot;dasdadas&quot;;    //进入内存的串池
String names =  &quot;dasdadas&quot;;
 System.out.println(name==names);  //true

 String n = new String(&quot;dasdadas&quot;);   //直接在堆空间中生成小空间
        System.out.println(name==n);  //false



       //字符串比较
        boolean equals = n.equals(name);
        System.out.println(&quot;equals:&quot;+equals);   //true
        boolean equal = n.equals(names);
        System.out.println(&quot;equal:&quot;+equal);   //true

        //字符串忽略大小写比较
        String s = new String(&quot;Abc&quot;);
        String s1 = &quot;abc&quot;;
        boolean b = s.equalsIgnoreCase(s1);
        System.out.println(b);   //true
</code></pre>
</li>
<li><p>Boolean equals 方法（要比较的字符串）                  完全一样结果是true，否则为false</p>
</li>
<li><p>Boolean equalslgnoreCase（要比较的字符串）       忽略大小写的比较</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>StringBuilder</p>
<ul>
<li><p>可以看成是一个容器，创建之后内容是可以改变的</p>
</li>
<li><p>StringBuilder常用方法</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907231629383.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220907231629383"></p>

</li>
<li><p>使用StringBuilder的场景</p>
<ul>
<li>字符串拼接</li>
<li>字符串的反转</li>
</ul>
</li>
</ul>
</li>
<li><p>StringJoiner</p>
<ul>
<li>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的</li>
<li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用</li>
<li>JDK8才出现的</li>
</ul>
</li>
<li><p>字符串原理</p>
<ul>
<li>&#x3D;&#x3D;号比较的到底是什么？<ul>
<li>基本数据类型比较数组值</li>
<li>引用数据类型比较地址值</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串拼接的底层原理</p>
<ul>
<li>如果很多字符串变量拼接，不要直接+。在底层会创建多个对象，浪费时间，浪费性能。</li>
<li>如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串</li>
<li>如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存</li>
</ul>
</li>
<li><p>StringBuilder底层原理</p>
<ul>
<li>所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存</li>
</ul>
</li>
<li><p>ArrayList集合</p>
<ul>
<li>长度可以变</li>
<li>集合不能直接存储基本数据类型</li>
</ul>
</li>
<li><p>static（静态）</p>
<ul>
<li>static表示静态，是java中的修饰符，可以修饰成员方法，成员变量</li>
<li>被static修饰的成员变量，叫做静态变量<ul>
<li>特点：<ul>
<li>被该类所有对象共享</li>
<li>不属于对象，属于类</li>
<li>随着类的加载而加载，优先于对象存在</li>
</ul>
</li>
<li>调用方法：<ul>
<li>类名调用</li>
<li>对象名调用</li>
</ul>
</li>
</ul>
</li>
<li>被static修饰的成员方法，叫做静态方法<ul>
<li><p>特点</p>
<ul>
<li>多用在测试类和工具类</li>
<li>javabean类中很少会用</li>
</ul>
</li>
<li><p>调用方法</p>
<ul>
<li>类名调用</li>
<li>对象名调用</li>
</ul>
</li>
</ul>
</li>
<li>工具类<ul>
<li>类名见名之义</li>
<li>私有化构造方法</li>
<li>方法都定义为静态方法，方便调用</li>
</ul>
</li>
<li>static的注意事项<ul>
<li>静态方法只能访问静态变量和静态方法</li>
<li>非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和静态的成员方法</li>
<li>静态方法中是没有this关键字</li>
</ul>
</li>
<li>总结：<ul>
<li>静态方法中，只能访问静态。</li>
<li>非静态方法可以访问所有。</li>
<li>静态方法中没有this关键字</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p>java中提供一个关键字extedns</p>
</li>
<li><p>当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码</p>
</li>
<li><p>什么是继承、继承的好处？</p>
<ul>
<li>继承是面向对象的三大特征之一，可以让类跟类之间产生子父的关系</li>
<li>可以把多个子类中重复的代码抽取到父类中，子类可以使用，减少代码冗余，提高代码的复用性</li>
</ul>
</li>
<li><p>继承的格式？</p>
<ul>
<li>public class 子类 extedns 父类 {}</li>
</ul>
</li>
<li><p>继承后子类的特点？</p>
<ul>
<li>子类可以得到父类的属性和行为，子类可以使用。</li>
<li>子类可以在父类的基础上新增其他功能子类更强大</li>
</ul>
</li>
<li><p>子类到底能继承父类中的哪些内容？（内存图&#x2F;内存分析工具）</p>
<img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220911173759076.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220911173759076" style="zoom:50%;" />

</li>
<li><p>继承的特点</p>
<ul>
<li>java只支持单继承，不支持多继承，但支持多层继承。<ul>
<li>一个子类只能继承一个父类，子类不能同时继承多个父类，子类A继承父类B，父类B可以继承父类C。</li>
</ul>
</li>
</ul>
</li>
<li><p>继承中：成员变量的访问特点</p>
<ul>
<li><p>就近原则：谁离我近，我就用随</p>
<ul>
<li>先在局部位置找，本类成员位置找，父类成员位置找，逐级往上</li>
</ul>
</li>
<li><p>如歌出现了重名的成员变量怎么办吗？</p>
<pre><code class="java">System.out.println(name);
System.out.println(this.name); 
System.out.println(super.name); //去找父类的name
</code></pre>
</li>
</ul>
</li>
<li><p>继承中：成员方法的访问特点</p>
</li>
<li><p>继承中：构造方法的访问特点</p>
<ul>
<li>父类中的构造方法不会被子类继承，但是可以通过super来调用</li>
<li>子类构造方法的第一行，有一个默认的super();</li>
<li>默认先访问父类中无参的构造方法，在执行自己</li>
<li>如果想要方法文父类有参构造方法，必须手动书写。</li>
<li>子类中所有的构造方法默认先访问父类中的无参构造，在执行自己</li>
</ul>
</li>
</ul>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul>
<li>方法的重写<ul>
<li>当父类的方法不能满足子类现在的需求时，需要进行方法的重写</li>
<li>重写方法的名称、形参列表必须与父类一致</li>
<li>子类重写父类方法时，访问权限子类必须大于等于父类（暂时了解：空着不写&lt;protected&lt;public)</li>
<li>子类重写父类的方法时，返回值类型子类必须小于父类</li>
<li>只有被添加到虚方法表中的方法才能被重写</li>
</ul>
</li>
<li>书写格式<ul>
<li>在继承体系中，子类出现了和父类中一模一样的方法声明，我们称子类这个方法是重写的方法</li>
</ul>
</li>
<li>@Override重写的注解<ul>
<li>@Override是放在重写后的方法上，校验子类重写是语法是否正确</li>
<li>加上注解后如果有红色波浪线，表示语法错误</li>
<li>建议重写方法都加上@Override注解，代码安全，优雅</li>
</ul>
</li>
</ul>
<h4 id="this，super"><a href="#this，super" class="headerlink" title="this，super()"></a>this，super()</h4><ul>
<li>this:理解为一个变量，表示当前方法调用者的地址值；</li>
<li>super:代表父类存储空间。</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220912094526173.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220912094526173">多态</h4><ul>

<li><p>​	什么是多态？</p>
<ul>
<li>同类型的对象，表现出的不同的形态</li>
</ul>
</li>
<li><p>​	多态的表现形式</p>
<ul>
<li>父类类型 对象名称 &#x3D; 子类对象；</li>
</ul>
</li>
<li><p>多态的前提</p>
<ul>
<li>有继承关系</li>
<li>有父类引用指向子类对象</li>
<li>有方法重写</li>
</ul>
</li>
<li><p>多态的好处？</p>
<ul>
<li>使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利</li>
</ul>
</li>
<li><p>多态调用成员的特点</p>
<ul>
<li>变量调用:编译看左边，运行看右边。</li>
<li>方法调用：编译看左边，运行看右边。</li>
</ul>
</li>
<li><p>多态的优势</p>
<ul>
<li>方法中，使用父类型作为参数，可以接受所有子类对象</li>
</ul>
</li>
<li><p>多态的弊端是什么？</p>
<ul>
<li>不能使用子类的特有功能</li>
</ul>
</li>
<li><p>引用数据类型的类型转换，有几种方式？</p>
<ul>
<li>自动类型转换，强制类型转换</li>
</ul>
</li>
<li><p>强制类型转换能解决什么问题？</p>
<ul>
<li>可以转换成真正的子类型类型，从而调用子类独有功能</li>
<li>转换类型与真实对象类型不一致会报错</li>
<li>转换的时候用instanceof关键字进行判断</li>
</ul>
</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>​	使用final修饰之后是不能改变的</p>
<ul>
<li>方法 表面该方法最终方法，不能被重写</li>
<li>类instanceof表面该类是最终类，不能被继承</li>
<li>变量 叫做常量，只能被赋值一次</li>
<li>final修饰变量：是常量，不能修改<ul>
<li>基本数据类型：变量的值不能修改</li>
<li>引用数据类型：地址值不能修改但是内部的属性值可以修改</li>
</ul>
</li>
</ul>
<p>使用场景</p>
<ul>
<li>​	一些系统不可被修改的常量</li>
</ul>
<h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><ul>
<li><p>private ： 私有的，只能 自己用</p>
</li>
<li><p>默认 ： 只能在本包里面用</p>
</li>
<li><p>protected ： 受保护的</p>
</li>
<li><p>public ： 公共的</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220912153212668.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220912153212668"></p>

</li>
</ul>
<ol>
<li>构造代码块<ol>
<li>写在成员位置的代码块</li>
<li>作用：可以把多个构造方法中重复的代码抽取出来</li>
<li>执行时机：我们在创建本类对象的时候会执行构造代码块再执行构造方法</li>
</ol>
</li>
<li>静态代码块<ol>
<li>格式：static{}</li>
<li>数据的初始化（重点）</li>
<li>执行时机：随着类的加载而加载的，并且只执行一次</li>
</ol>
</li>
</ol>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>抽象类<ul>
<li>public abstract class 类名{}</li>
<li>如果一个<u>类中存在抽象方法</u>，那么这个类就<u>必须声明为抽象类</u></li>
</ul>
</li>
<li>抽象方法<ul>
<li>格式:public abstract 返回值类型 方法名（参数列表）；</li>
<li>抽象方法：将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容不一样，所以，再父类中不能确定具体的方法体。该方法就可以定义为抽象方法。</li>
</ul>
</li>
<li>子类继承抽象类之后，如何重写抽象方法</li>
<li>抽象类和抽象方法注意事项<ul>
<li>抽象类不能实例化（抽象类不能创建对象）</li>
<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>
<li>可以有构造方法</li>
<li>抽象的子类<ul>
<li>要么重写抽象类中的所有抽象方法</li>
<li>要么是抽象类</li>
</ul>
</li>
</ul>
</li>
<li>抽象类的作用是声明样的？<ul>
<li>抽取共性时，无法确定方法体，就把方法定义为抽象的，强制让子类按照某种格式重写。</li>
</ul>
</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li>接口：就是一种规则</li>
<li>接口的定义和使用<ul>
<li>接口用关键字interface来定义<ul>
<li>public interface 接口名{}</li>
</ul>
</li>
<li>接口不能实例化</li>
<li>接口和类之间是实现关系，通过implements关键字表示<ul>
<li>public class 类名implement 接口名 {}</li>
</ul>
</li>
<li>接口的子类（实现类）<ul>
<li>要么重写接口中的所有抽象方法</li>
<li>要么是抽象类</li>
</ul>
</li>
</ul>
</li>
<li>接口成员的特点<ul>
<li>成员变量<ul>
<li>只能是常量</li>
<li>默认修饰符：public static final</li>
</ul>
</li>
<li>没有构造方法</li>
<li>成员方法<ul>
<li>只能是抽象方法</li>
<li>默认修饰符：public abstract</li>
</ul>
</li>
<li>jdk7以前：接口只能定义抽象方法</li>
</ul>
</li>
<li>接口和类之间的关系<ul>
<li>类和类之间的关系<ul>
<li>继承关系，只能单继承，不能多继承，但是可以多层继承</li>
</ul>
</li>
<li>类和接口的关系<ul>
<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>
</ul>
</li>
<li>接口和接口的关系<ul>
<li>继承关系，可以单继承，也可以多继承</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul>
<li><p>类的五大成员：</p>
<ul>
<li>属性，方法，构造方法、代码块、内部类</li>
</ul>
</li>
<li><p>内部类的分类</p>
<ul>
<li><p>成员内部类</p>
<ul>
<li><p>写在成员位置，属于外部类的一员</p>
</li>
<li><p>成员内部类可以被修饰符所修饰</p>
</li>
<li><p>在成员内部类里面，JDK16之前不能定义静态变量，JDK16才开始可以定义静态变量</p>
</li>
<li><p>调用格式</p>
<pre><code>package Day;

public class Day06Test &#123;


    public static void main(String[] args) &#123;
        
//        创建内部类对象
        Day06.Engine  e= new Day06().new Engine();
        e.show();
        //创建内部类对象,在外部类创建一个成员方法来调用内部类的对象
        Day06 d = new Day06();
        Day06.Engine engine = d.getEngine();
        engine.show();
    &#125;


&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>静态内部类</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220914224011897.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220914224011897"></p>

</li>
<li><p>局部内部类</p>
<ul>
<li>将内部类定义在方法里面就叫做局部内部类，类似于方法的局部变量</li>
<li>外界是无法直接使用，需要在方法内部创建对象并使用</li>
<li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li>
</ul>
</li>
<li><p>匿名内部类</p>
<ul>
<li>内部类本质上就是隐藏了名字的内部类</li>
<li>定义格式</li>
</ul>
<pre><code>new 类名或者接口名()&#123;      //如歌类名是类那么就是继承关系，如果是接口名那么就是实现接口
    重写方法;
&#125;;
</code></pre>
</li>
</ul>
</li>
<li><p>什么是内部类</p>
<ul>
<li>在一个类中，再定义一个类</li>
</ul>
</li>
<li><p>内部类的访问特点</p>
<ul>
<li><p>内部类可以直接访问外部类的成员，包括私有</p>
</li>
<li><p>外部类要访问内部类的成员，必须创建对象</p>
<pre><code>package Day;

public class Day06 &#123;
    String carName;
    int carAGe;
    String carColor;
     int a = 30;

    //定义一个外部类的方法
    public  void  shows()&#123;
        //外部类访问成员变量
        System.out.println(carAGe);
        //外部类访问不了内部类的成员变量
//        System.out.println(engineAgge);
        //外部类访问不了内部类的成员方法
//        show();

    &#125;

    //定义一个内部类
    class Engine&#123;
        String engineName;
        int engineAgge;
        int a = 10;

        //定义一个内部类的方法
        public void show()&#123;
             int a = 20;
            //内部类访问内部类的成员变量
            System.out.println(engineName);
            //内部类访问外部类的成员变量
            System.out.println(carName);
            //内部类访问外部类的成员方法
            shows();
            //如果内部类和外部类的成员变量同名需要以下方法调用
             System.out.println(a);//20
             System.out.println(this.a);  //10
             System.out.println(Day06.this.a);//30
        &#125;
    &#125;

&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><pre><code>package math;

public class MathTest &#123;
    public static void main(String[] args) &#123;
        float a = 314554.88f;
        int round = Math.round(a);
        System.out.println(round);


        //返回绝对值
        int b = -100;
        int abs = Math.abs(b);
        System.out.println(abs);

        //返回两个数的总数 如果数据超出int范围会抛出异常
        int x = 2, y = 10;
        int i = Math.addExact(x, y);
        System.out.println(i);
        //返回乘数的乘积

        //比较两个数的最大值
        int maxA= 10,maxB=20;
        int max = Math.max(maxA, maxB);
        System.out.println(max);


        //比较两个数的最小值
        int minA=50,minB=60;
        int min = Math.min(minA, minB);
        System.out.println(min);

        //返回两个数的相乘
        int i1 = Math.multiplyExact(x, y);
        System.out.println(i1);

        //向上取整
        System.out.println(Math.ceil(20.85));//21.0

        //向下取整
        System.out.println(Math.floor(20.85));//20.0

        //代表2的三次方，如果第二个参数是0~1之间的小数
        System.out.println(Math.pow(2, 3)); //8.0
        System.out.println(Math.pow(2, 0.5)); //1.4142135623730951

        //代表开根号
        System.out.println(Math.sqrt(98)); //2.0

        //开立方根
        System.out.println(Math.cbrt(8));//2.0


    &#125;
&#125;
</code></pre>
<h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220918172005955.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220918172005955" style="zoom:67%;" />


<pre><code>package math;

public class SystemTest &#123;
    public static void main(String[] args) &#123;
        //0:表示当前虚拟机是正常停止
        //非0，表示当前虚拟机异常停止
//        System.exit(0);

        long l = System.currentTimeMillis();
        System.out.println(l);

        //拷贝数组
        int[] arr1 = &#123;1,2,3,4,5,6,7,8,9,10&#125;;
        int[] arr2 = new int[10];
        //第一个参数：数据源，要拷贝的数据
        //第二个参数：从数据源哪个索引开始拷贝
        //第三个参数：新数组
        //第四个参数：拷贝到新数组的哪个位置
        //第五个参数：拷贝多少个数据
//        System.arraycopy(arr1,3,arr2,0,7);


        //课堂练习 arr2 : 0 0 0 0 1 2 3 0 0 0
        System.arraycopy(arr1,0,arr2,4,3);




        for (int i = 0; i &lt; arr2.length; i++) &#123;
            System.out.print(arr2[i]+&quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><ul>
<li><p>Runtime表示当前虚拟机的运行环境</p>
<pre><code>package math;

import java.io.IOException;

public class RuntimeTest &#123;
    public static void main(String[] args) &#123;
        Runtime runtime = Runtime.getRuntime();
        System.out.println(runtime);
        int i = runtime.availableProcessors();    //获取CPU的线程数
        System.out.println(i);//12
        long l = runtime.maxMemory();   //JVM能从系统中获取总内存大小(单位byte)
        System.out.println(l);
        long l1 = runtime.totalMemory();   //JVM已经从系统中获取总内存大小(单位byte)
        System.out.println(l1);

        long l2 = runtime.freeMemory();   //获取jvm剩余多少内存可以使用
        System.out.println(l2);

        try &#123;
           runtime.exec(&quot;notepad&quot;); //运行cmd命令 notepad打开记事本
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul>
<li><p>Object是java中定级父类。所有类都直接或间接的继承于Object类</p>
</li>
<li><p>Object类中的方法可以被所有子类访问。</p>
</li>
<li><p>Object方法</p>
<ul>
<li>toString</li>
<li>equals</li>
<li>clone()&#96; 对象克隆<ul>
<li>方法在底层会帮我们创建一个对象，并把原对象中的数据拷贝过去</li>
<li>重写Object中的clone方法</li>
<li>让JavaBean类实现Cloneable接口</li>
<li>创建元对象并调用clone就可以了</li>
<li>浅克隆</li>
<li>深克隆<ul>
<li>以下的代码深克隆还是有弊端，因为以后是个二维数组又要修改，所以会使用第三方写的代码Gson</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>package math;

import java.util.Arrays;
import java.util.Objects;

public class Student implements Cloneable &#123;
    private String name;
    private int  age;

    private int[] arr;


    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public int[] getArr() &#123;
        return arr;
    &#125;

    public void setArr(int[] arr) &#123;
        this.arr = arr;
    &#125;

    public Student(String name, int age, int[] arr) &#123;
        this.name = name;
        this.age = age;
        this.arr = arr;
    &#125;

    public Student() &#123;
    &#125;

    //重写object中的toString
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, arr=&quot; + Arrays.toString(arr) +
                &#39;&#125;&#39;;
    &#125;
    //重写object中的equals
    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age &amp;&amp; Objects.equals(name, student.name) &amp;&amp; Arrays.equals(arr, student.arr);
    &#125;

    //重写object中的clone
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;

        //如果想深克隆,不加这个就是浅克隆。浅克隆如果是引用类型那么复制的是地址值，如果成员属性中有数组，那么复制的是地址值，
        // 如果其中一个修改数组中的元素就会跟着修改，所以定义深克隆

        int[] data = this.arr;
        //创建新数组，将旧数组里面的数据直接拷贝的新数组里面
        int[]  newData = new int[data.length];
        for (int i = 0; i &lt; data.length; i++) &#123;
            newData[i] = data[i];
        &#125;
       //直接调用父类中的方法克隆对象
        Student s = (Student) super.clone();
        s.arr = newData;
        return s;
    &#125;


    /**
     * 浅克隆
     */
//    @Override
//    protected Object clone() throws CloneNotSupportedException &#123;
//        return super.clone();
//    &#125;
&#125;
</code></pre>
<pre><code>package math;

public class ObjectTest &#123;
    public static void main(String[] args) throws CloneNotSupportedException &#123;

        int[] data= &#123;1,2,3,4,5,6,7,8,9,10&#125;;
        Student s = new Student(&quot;蔡&quot;,20,data);
        System.out.println(s);   //Student&#123;name=&#39;蔡&#39;, age=20, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;  在javaBean中重写toString就可以这样显示
        System.out.println(s);    //math.Student@1b6d3586    如果没有重写toString方法就会打印出地址值，会使用Object的toString


        Student s1 = new Student();
        Student s2 = new Student();
        boolean result = s1.equals(s2);
        System.out.println(result);   //false  如果在javaBean中不重写equals方法就会比较两个对象的地址值两个地址值是new出来的所以在内存堆中,会使用Object的equals

        System.out.println(result);   //true  如果在javaBean中重写equals方法就会使用javaBean中重写的equals方法。



        //直接调用javabean类中重写的克隆方法
        Student s4 = (Student) s.clone();
        //修改拷贝后数组的第一个元素的数据
        int[] arr = s4.getArr();
        arr[0] = 55;
        System.out.println(s4);  //Student&#123;name=&#39;蔡&#39;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;
        System.out.println(s);  //原数组的数组第一个数据也被修改了Student&#123;name=&#39;蔡&#39;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;


        //在javabean中重写了浅克隆，变成了深克隆
        System.out.println(s4);  //Student&#123;name=&#39;蔡&#39;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;
        System.out.println(s);   //Student&#123;name=&#39;蔡&#39;, age=20, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;


    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><ul>
<li><p>BigInteger构造方法</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220919214226833.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220919214226833"></p>

</li>
</ul>
<h4 id="BigDecima"><a href="#BigDecima" class="headerlink" title="BigDecima"></a>BigDecima</h4><ul>
<li><p>用于小数的精确计算</p>
</li>
<li><p>用来表示很大的小数</p>
<pre><code>package math;

import java.math.BigDecimal;

public class BigDecimalTest &#123;
    public static void main(String[] args) &#123;

        //使用double形参构造函数会数据不精确
        BigDecimal b = new BigDecimal(0.01);
        BigDecimal bg = new BigDecimal(0.09);
        BigDecimal bg1 = b.add(bg);
        System.out.println(b);  //0.01000000000000000020816681711721685132943093776702880859375
        System.out.println(bg);//0.0899999999999999966693309261245303787291049957275390625
        System.out.println(bg1);//0.09999999999999999687749774324174723005853593349456787109375


        //使用String形参构造函数数据精确
        BigDecimal b1 = new BigDecimal(&quot;0.01&quot;);
        BigDecimal b2 = new BigDecimal(&quot;0.09&quot;);
        //add b1加上b2
        BigDecimal b3 = b1.add(b2);
        System.out.println(b1);  //0.01
        System.out.println(b2);//0.09
        System.out.println(b3);//0.10

    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul>
<li><p>作用</p>
<ul>
<li><p>检验字符串是否满足规则</p>
</li>
<li><p>在一段文本中查找满足要求的内容</p>
</li>
<li><p>正则表达式字符的基本操作</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220923130744244.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220923130744244"></p>

</li>
</ul>
<pre><code>package Day.Api.zhengze;

public class Test &#123;
    public static void main(String[] args) &#123;
        //判断一个是不是qq号
        String qq = &quot;1311871826&quot;;
        //[1-9]这个代表上面第一个数字不能以0开头  \\d代表数字 &#123;4,9&#125;这个代表除了第一个数字后面的数必须是4~9位数字要不然就是返回false
        System.out.println(qq.matches(&quot;[1-9]\\d&#123;4,9&#125;&quot;));

        System.out.println(&quot;-------------------------&quot;);

        System.out.println(&quot;a&quot;.matches(&quot;[abc]&quot;));  //true
        System.out.println(&quot;z&quot;.matches(&quot;[abc]&quot;));  //false
        System.out.println(&quot;ab&quot;.matches(&quot;[abc]&quot;)); //false  因为这样[abc]只能匹配字符串一个字符所以false所以要改成[abc][abc]这个就是true

        System.out.println(&quot;-------------------------&quot;);


        //[^abc]  ^取反的意思
        System.out.println(&quot;a&quot;.matches(&quot;[^abc]&quot;));  //false
        System.out.println(&quot;z&quot;.matches(&quot;[^abc]&quot;));  //true
        System.out.println(&quot;zz&quot;.matches(&quot;[^abc]&quot;));  //false
        System.out.println(&quot;zz&quot;.matches(&quot;[^abc][^abc]&quot;));//true


        System.out.println(&quot;---------------------------&quot;);
        //[a-zA-Z]可以是a-z的大写和小写
        System.out.println(&quot;a&quot;.matches(&quot;[a-zA-Z]&quot;)); //true
        System.out.println(&quot;Z&quot;.matches(&quot;[a-zA-Z]&quot;)); //true
        System.out.println(&quot;aa&quot;.matches(&quot;[a-zA-Z]&quot;));//false    //[a-zA-Z][a-zA-Z] true
        System.out.println(&quot;zz&quot;.matches(&quot;[a-zA-Z]&quot;));//false
        System.out.println(&quot;0&quot;.matches(&quot;[a-zA-Z]&quot;));//false    //[a-zA-Z0-9] false  //[0-9] true


        System.out.println(&quot;----------------------&quot;);
        //[a-d[m-p]] a到d，或m到p
        System.out.println(&quot;a&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true
        System.out.println(&quot;d&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true
        System.out.println(&quot;m&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true
        System.out.println(&quot;p&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true
        System.out.println(&quot;e&quot;.matches(&quot;[a-d[m-p]]&quot;)); //false   //e不在范围内所以是false
        System.out.println(&quot;0&quot;.matches(&quot;[a-d[m-p]]&quot;)); //false  //0是数字正则匹配里面没有数字

        System.out.println(&quot;--------------------------&quot;);



        //[a-z&amp;&amp;[def]]
        //其实就是它们的交集  def
        System.out.println(&quot;d&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //true
        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //false
        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //false


        //[a-z&amp;&amp;[^bc]]  除了bc字母都可以
        System.out.println(&quot;-------------------&quot;);
        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //true
        System.out.println(&quot;b&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //false
        System.out.println(&quot;z&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //true
        System.out.println(&quot;z&quot;.matches(&quot;[a-z&amp;[^bc]]&quot;));  //true 因为&amp;只能当当是符号不是&amp;&amp;这个才是且

        System.out.println(&quot;-------------------------&quot;);

        //[a-z&amp;&amp;[^m-p]]  除了m-p中的字母，其它字母都可以
        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //true
        System.out.println(&quot;m&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //false
        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //false

  &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="jDK7前时间类"><a href="#jDK7前时间类" class="headerlink" title="jDK7前时间类"></a>jDK7前时间类</h4><p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924144225531.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220924144225531"></p>

<ul>
<li><p>Date  时间</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924150106666.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220924150106666"></p>

</li>
<li><p>SimpleDateFormat 格式化时间</p>
<ul>
<li>作用<ul>
<li>格式化：把时间变成自己的格式</li>
<li>解析：把字符串表示的时间变成Date</li>
</ul>
</li>
</ul>
<pre><code>package Day.Api.date;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateTest &#123;
    public static void main(String[] args) throws ParseException &#123;
    
        //时间原点
        Date date1 = new Date(0L);
        System.out.println(date1); //Thu Jan 01 08:00:00 CST 1970
    
        Date date = new Date();
        System.out.println(date);
        //格式化时间YYYY年MM月dd日 HH:mm:ss E
        SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss E&quot;);
        String format = s.format(date);
        System.out.println(format);  //2022年09月24日 15:23:32 星期六


        //解析时间
        String d = &quot;2022-09-24 15-26-20&quot;;
        SimpleDateFormat sp = new SimpleDateFormat(&quot;yyyy-MM-dd HH-mm-ss&quot;);
        Date parse = sp.parse(d);
        System.out.println(parse); //Sat Sep 24 15:26:20 CST 2022


    &#125;
&#125;
</code></pre>
</li>
<li><p>Calendar 日历</p>
<pre><code>package Day.Api.date;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateTest &#123;
    public static void main(String[] args) throws ParseException &#123;



       //Calendar 是一个抽象类，不能直接new

        Calendar c = Calendar.getInstance();

        int year = c.get(Calendar.YEAR);
        int moth = c.get(Calendar.MONTH) + 1;
        int dt = c.get(Calendar.DATE);
        int week = c.get(Calendar.DAY_OF_WEEK);  // 1(星期日) 2(星期一) 3(星期二) 4(星期三) 5(星期四) 6(星期五) 7(星期六)
        System.out.println(year+&quot;年&quot;+moth+&quot;月&quot;+dt+&quot;日&quot;+&quot; &quot;+week(week)); //2022年9月24日

        //修改年为2023年
        c.set(Calendar.YEAR,2023);
        System.out.println(c.get(Calendar.YEAR));
        //如果想修改月份为12月，那么修改值要填11，因为Calendar的月份是少1的
        c.set(Calendar.MONTH,11);
        System.out.println(c.get(Calendar.MONTH));
    &#125;

    //定义一个方法传入外国人对星期几的数字转换成中文
    public static String week(int week)&#123;
        String[] wek = &#123;&quot;&quot;,&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;&#125;;
        return wek[week];
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="jdk8时间类"><a href="#jdk8时间类" class="headerlink" title="jdk8时间类"></a>jdk8时间类</h4><ul>
<li>为什么要学jdk8新增时间相关类<ul>
<li>代码层面<ul>
<li>jdk：代码麻烦 </li>
<li>jdk8：简单<ul>
<li>判断的方法</li>
<li>计算时间间隔的方法</li>
</ul>
</li>
</ul>
</li>
<li>安全层面<ul>
<li>jdk：多线程环境下会导致数据安全的问题</li>
<li>jdk8：时间日期对象都是不可变的，解决了这个问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924165212609.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220924165212609"></p>

<ul>
<li><p>时区，时间戳，带时区的时间，格式化和解析时间</p>
<pre><code>package Day.Api.date;

import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Set;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/9/24
 * Time: 16:37
 * 需求：
 */
public class DateTest01 &#123;
    public static void main(String[] args) &#123;


        //ZoneId
        //获取java中所有支持时区
        Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();
        System.out.println(availableZoneIds);

        //获取电脑时区
        ZoneId zoneId = ZoneId.systemDefault();
        System.out.println(zoneId); //Asia/Shanghai
        //设置指定的时区
        ZoneId of = ZoneId.of(&quot;Asia/Aden&quot;);
        System.out.println(of);

        System.out.println(&quot;---------Instant--------------&quot;);

        //获取的世界标准时间对象，如果想获取当前时间小时需要加8个小时
        Instant now = Instant.now();
        System.out.println(now);

        /**
         * 根据（秒/毫秒/纳秒）获取Instant对象
         */
        //根据纳秒获取
        Instant instant1 = Instant.ofEpochMilli(0L);
        System.out.println(instant1);//1970-01-01T00:00:00Z

        //根据秒
        Instant instant2 = Instant.ofEpochSecond(1);
        System.out.println(instant2);//1970-01-01T00:00:01Z 根据时间原点加一秒

        //第一个参数根据秒 ，第二个参数根据纳秒
        Instant instant3 = Instant.ofEpochSecond(1L, 1000000000L);
        System.out.println(instant3);//1970-01-01T00:00:02Z


        //指定地区的时间点
        ZonedDateTime zonedDateTime = now.atZone(ZoneId.of(&quot;Asia/Shanghai&quot;));
        System.out.println(zonedDateTime);//2022-09-25T18:40:57.110030600+08:00[Asia/Shanghai]

        System.out.println(&quot;----------ZonedDateTime-----------&quot;);

        //获取当前时区时间的对象
        ZonedDateTime now1 = ZonedDateTime.now();
        System.out.println(now1);//2022-09-25T18:46:16.151643500+08:00[Asia/Shanghai]


        System.out.println(&quot;-----------------DateTimeFormatter---------------&quot;);
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);
        String format = dateTimeFormatter.format(now1);
        System.out.println(format);

    &#125;

&#125;
</code></pre>
</li>
</ul>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><ul>
<li>什么是包装类<ul>
<li>基本数据类型对应的对象</li>
</ul>
</li>
<li>JDK5新增的特性<ul>
<li>自动装箱</li>
<li>自动拆箱</li>
</ul>
</li>
<li>各个基本类型的包装类</li>
</ul>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220929215914294.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20220929215914294"></p>

<p>​						</p>
<pre><code>package Day.packaging;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/9/29
 * Time: 21:56
 * 需求：
 */
public class TestInteger &#123;

    public static void main(String[] args) &#123;

        //包装类，数字引用数字类型 Jdk5写法
        //利用构造方法来创建对象
        System.out.println(&quot;----------构造法创建对象---------------&quot;);
        Integer a = new Integer(10);
        Integer a1 = new Integer(&quot;10&quot;);
        System.out.println(a);
        System.out.println(a1);

        System.out.println(&quot;--------------静态方法创建对象------------------&quot;);

        //利用静态方法创建对象
        Integer in = Integer.valueOf(10);
        Integer integer = Integer.valueOf(&quot;123&quot;);
        Integer integer1 = Integer.valueOf(&quot;123&quot;, 8);
        System.out.println(in);
        System.out.println(integer);
        System.out.println(&quot;输出8进制的数:&quot;+integer1);

        Integer c=10;
        System.out.println(c);


        //两个创建的对象区别
        //这个判断的是数字如果数字不在-128~127那么源码中会new出来的所以超过127就是判断地址值
        Integer i5 = Integer.valueOf(127);
        Integer i6 = Integer.valueOf(127);
        System.out.println(i5==i6);  //true


        Integer i7 = Integer.valueOf(128);
        Integer i8 = Integer.valueOf(128);
        System.out.println(i7==i8);  //false


        //底下这种判断的是地址值所以是false
        Integer i1 = new Integer(127);
        Integer i2 = new Integer(127);
        System.out.println(i1==i2);//false


        Integer i3 = new Integer(128);
        Integer i4 = new Integer(128);
        System.out.println(i3==i4);//false

    &#125;

&#125;
</code></pre>
<h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><ul>
<li><p>查找算法</p>
<ul>
<li><p>基本查找    </p>
<ul>
<li><p>基本查找的实现</p>
<pre><code>package find;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/9/30
 * Time: 12:52
 * 需求：查找算法
 */
public class BasicSearch &#123;
    public static void main(String[] args) &#123;

        int[] arr = &#123;20,30,40,60,70,90,100,120,150&#125;;

        //基本查找
        boolean b = basicSearch(arr, 20);
        System.out.println(b);
    &#125;



    //基本查找
    public static boolean basicSearch(int Array[],int number)&#123;
        for (int i = 0; i &lt; Array.length; i++) &#123;
            if (Array[i]==number)&#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;

&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>二分查找&#x2F;折半查找</p>
<ul>
<li><p>二分查找前提条件是数组的数据是顺序的</p>
</li>
<li><p>提高查找效率</p>
</li>
<li><p>二分查找过程</p>
<ul>
<li>min和max表示当前要查找的范围</li>
<li>中间是在min和max中间的</li>
<li>如果要查找的元素在mid的左边，缩小范围时，min不变， max等于mid减1</li>
<li>如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1</li>
</ul>
</li>
<li><p>二分查找的代码实现</p>
<ul>
<li><pre><code>package find;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/9/30
 * Time: 12:52
 * 需求：查找算法
 */
public class BasicSearch &#123;
    public static void main(String[] args) &#123;

        int[] arr = &#123;20,30,40,60,70,90,100,120,150&#125;;


        int i = ErBasicSearch(arr, 30);
        System.out.println(i);
    &#125;

    //二分查找

    /**
     *
     * @param Array
     * @param number
     * @return
     * 1, min和max表示当前要查找的范围
     * 2，中间是在min和max中间的
     * 3,如果要查找的元素在mid的左边，缩小范围时，min不变， max等于mid减1
     * 4,如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1
     */
    public static int ErBasicSearch(int Array[],int number)&#123;
        int max =   Array.length-1;
        int min = 0;
        while (true)&#123;
            int mid = (max+min)/2;
            if (min&gt;max)&#123;
                return -1;
            &#125;
            if (Array[mid]&gt;number)&#123;
                max=mid-1;

            &#125;else if (Array[mid]&lt;number)&#123;
                min = mid+1;
            &#125;else  &#123;
                return mid;
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><ul>
<li><p>常用方法</p>
<ul>
<li><pre><code>package Day.Api.Arrays;


import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/10/2
 * Time: 16:42
 * 需求：
 */
public class MyArrayTest01 &#123;

    public static void main(String[] args) &#123;
        int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;
        System.out.println(&quot;--------Arrays toString----------------&quot;);
        //返回指定数组内容的字符串表示形式
        System.out.println(Arrays.toString(arr));  //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


        //使用二分查找查找元素
        //第一:二分查找的数组中的元素是有序的，而且是升序的
        //第二：如果查找的数据存在返回索引
        System.out.println(&quot;--------Arrays binarySearch----------------&quot;);
        System.out.println(Arrays.binarySearch(arr, 5));//4
        System.out.println(Arrays.binarySearch(arr, 10));//9
        System.out.println(Arrays.binarySearch(arr, 20));//-11


        //复制新数组
        //第一个参数是旧数组的数据
        //第二个参数是，要从数组中的复制多少个数据到新数组，如果新数组的长度大于旧数组的长度，那么后面的数据用数组的初始值
        System.out.println(&quot;--------Arrays copyOf----------------&quot;);
        int[] ints = Arrays.copyOf(arr, 20);
        System.out.println(Arrays.toString(ints));


        //排序
        System.out.println(&quot;--------Arrays sort  升序----------------&quot;);
        Integer[] array = &#123;20, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;;

//        Arrays.sort(array);
//        System.out.println(Arrays.toString(array));



        //降序排序o2-o1
        //升序排序o1-o2
        Arrays.sort(array,new Comparator&lt;Integer&gt;()&#123;

            @Override
            public int compare(Integer o1, Integer o2) &#123;

                return o2-o1;
            &#125;
        &#125;);
        System.out.println(Arrays.toString(array));
    &#125;

&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="lambda-JDK8"><a href="#lambda-JDK8" class="headerlink" title="lambda  JDK8"></a>lambda  JDK8</h4><ul>
<li>注意事项<ul>
<li>Lambda表达式可以用来简化匿名内部类的书写</li>
<li>Lambda表达式只能简化函数式接口的匿名内部类的写法</li>
<li>函数式接口：<ul>
<li>有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>package Day.Api.Arrays;

import java.util.Arrays;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/10/2
 * Time: 17:22
 * 需求：
 */
public class LambdaTest &#123;
    public static void main(String[] args) &#123;

        Integer[] array = &#123;20, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;;
        //降序排序
        // lambda表达式 -&gt;
//        Arrays.sort(array, (Integer o1, Integer o2) -&gt; &#123;
//                    return o2 - o1;
//                &#125;
//        );
        //Integer如果数据类型相同们可以省略
//        Arrays.sort(array, (o1,  o2) -&gt; &#123;
//                    return o2 - o1;
//                &#125;
//        );
        //也可以省略花括号和return
        Arrays.sort(array, (o1,  o2) -&gt;o2 - o1);
        System.out.println(Arrays.toString(array));
    &#125;

&#125;
</code></pre>
<h4 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h4><ul>
<li><p>Collection：是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的</p>
<ul>
<li>遍历方式<ul>
<li>迭代器遍历</li>
<li>增强for遍历</li>
<li>Lambda表达式遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>List</p>
<ul>
<li>添加的元素是有序的、可重复、有索引</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li>添加的元素是无序、不重复、五索引</li>
</ul>
</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li>迭代器遍历<ul>
<li>迭代器在java中类是Iterator，迭代器是集合专用的遍历方式。</li>
</ul>
</li>
<li>Collection集合获取迭代器</li>
<li>注意事项<ul>
<li>报错NoSuchElementException</li>
<li>迭代器遍历完毕，指针不会复位</li>
<li>迭代器遍历时，不能用集合的方法进行增强或者删除</li>
</ul>
</li>
</ul>
<pre><code>package Day;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/10/3
 * Time: 16:56
 * 需求：迭代器遍历
 */
public class Day186 &#123;
    public static void main(String[] args) &#123;

        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aaa&quot;);
        list.add(&quot;bbb&quot;);
        list.add(&quot;ccc&quot;);

        Iterator&lt;String&gt; it = list.iterator();

        //查看集合指针位置是否有元素，如果有数就是true，没有就是false
        while (it.hasNext())&#123;
            //使用next方法获取第一个元素，并且移动指针到集合的第二个位置
            String str = it.next();
            System.out.println(str);
        &#125;
    &#125;

&#125;
</code></pre>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003172048287.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20221003172048287"></p>

<h4 id="集合遍历方式"><a href="#集合遍历方式" class="headerlink" title="集合遍历方式"></a>集合遍历方式</h4><pre><code>package Day;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/10/3
 * Time: 18:49
 * 需求：List 五种遍历
 */
public class Day188 &#123;

    public static void main(String[] args) &#123;
        List&lt;String&gt; list  = new ArrayList&lt;&gt;();

        list.add(&quot;aaa&quot;);
        list.add(&quot;bbb&quot;);
        list.add(1,&quot;ccc&quot;);
        System.out.println(list);

        //迭代器遍历  如果想删除元素请用迭代器遍历
        Iterator&lt;String&gt; it = list.iterator();
        while (it.hasNext())&#123;
            String str = it.next();
            if (&quot;bbb&quot;.equals(str))&#123;
                it.remove();
            &#125;
            System.out.println(str);
        &#125;
        System.out.println(list);
        //列表迭代器遍历  如果想添加元素请用列表迭代器遍历
        ListIterator&lt;String&gt; itList = list.listIterator();
        while (itList.hasNext())&#123;
            String str = itList.next();
            if (&quot;aaa&quot;.equals(str))&#123;
                itList.add(&quot;bbb&quot;);
            &#125;
            System.out.println(str);
        &#125;
        System.out.println(list);

        //如果单纯遍历数据请用增强for或Lambda表达式遍历
        for (String s : list) &#123;
            System.out.print(s+&quot; &quot;);
        &#125;
        System.out.println();

        list.forEach(s -&gt; System.out.print(s+&quot; &quot;));

        System.out.println();
        //如果想操作索引，使用普通for
        for (int i = 0; i &lt; list.size(); i++) &#123;
            System.out.print(list.get(i)+&quot; &quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>什么是数据结构</p>
<ul>
<li>计算机存储、组织数据的方式</li>
<li>是指数据相互之间是以什么方式排列在一起的</li>
<li>数据结构是为了更加方便的管理和使用数据，需要结合具体的业务场景来进行选择</li>
<li>一般情况下，精心选择数据结构可以带来跟高的运行或者存储效率</li>
</ul>
</li>
<li><p>常见的数据结构</p>
<ul>
<li><p>栈</p>
<ul>
<li><p>栈的特点：后进先出，先进后出</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003191448309.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20221003191448309"></p>

</li>
</ul>
</li>
<li><p>队列</p>
<ul>
<li><p>特点：先进先出，后进后出</p>
<p><img class="lazyload lazyload-style-1" src="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+"  data-original="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003191404657.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="image-20221003191404657"></p>

</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li>特点：内存连续区域，查询快，增删慢</li>
</ul>
</li>
<li><p>链表</p>
<ul>
<li>特点：元素是游离的，查询慢，首尾操作极快</li>
</ul>
</li>
<li><p>二叉树</p>
<ul>
<li>二叉查找树遍历方式</li>
<li>前序遍历：当前节点，左子节点，右子节点<ul>
<li>中序遍历：左子节点，中子节点，右子节点</li>
<li>后序遍历：左子节点，右子节点，当前节点</li>
<li>层序遍历：一层一层的去遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉查找树平衡二叉树</p>
</li>
<li><p>红黑树</p>
<ul>
<li>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构</li>
<li>1972年出现，当时被称为平衡二叉B树。后来，1978年被修改为如今的“红黑叔”</li>
<li>它是一种特殊的二叉树查找树，红黑树的每一个节点上都有存储位表示节点的颜色</li>
<li>每一个节点可以是红或者黑，红黑树不是高度平衡的，它的平衡是通过“红黑规则”进行实现的</li>
<li>红黑树规则<ul>
<li>每一个节点或是红色的，或是黑色的</li>
<li>根节点必须是黑色的</li>
<li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点（Nil）是黑色的</li>
<li>如果某一个节点是红色，那么它的节点必须是黑色（不能出现两个红色节点相连的情况）</li>
<li>对每一个节点，从节点到其所有后代叶节点的简单路劲上，均包含相同的黑色节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ArrayList底层原理"><a href="#ArrayList底层原理" class="headerlink" title="ArrayList底层原理"></a>ArrayList底层原理</h4><ul>
<li>利用空参创建的集合，在底层创建一个默认长度为0的数组</li>
<li>添加一个元素时，底层会创建一个新的长度为10的数组</li>
<li>存满时，会扩容1.5倍</li>
<li>如果一次添加多个元素，1.5倍还放不下，则新床数组的长度以实际为准</li>
</ul>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ul>
<li><p>什么是泛型</p>
<ul>
<li>JDK5引入的特性，可以在编译阶段约束操作的数据类类型，并进行检查</li>
</ul>
</li>
<li><p>泛型好处</p>
<ul>
<li>统一数据类型</li>
<li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来</li>
</ul>
</li>
<li><p>泛型的细节</p>
<ul>
<li>泛型中不能写基本数据类型</li>
<li>指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型</li>
<li>如果不写泛型，类型默认是Object</li>
</ul>
</li>
<li><p>哪里可以定义泛型</p>
<ul>
<li>泛型类：在类名后定义泛型，创建该类对象的时候，确定类型</li>
<li>泛型方法：在修饰符后面定义泛型，调用方法的时候确定类型</li>
<li>泛型接口：在接口名后面定义泛型，实现类确定类型，实现类延续泛型</li>
</ul>
</li>
<li><p>泛型的继承和通配符</p>
<ul>
<li>泛型不具备继承性，但是数据具备继承性</li>
</ul>
</li>
</ul>
<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><ul>
<li>无序：存取顺序不一致</li>
<li>不重复：可以去除重复</li>
<li>无索引：没有带索引的方法，所以不能使用普通for遍历，也不能通过索引来获取元素</li>
<li>set集合实现类<ul>
<li>HashSet：无序、不重复、无索引</li>
<li>LinkedHashSet：有序、不重复、无索引</li>
<li>TreeSet：可排序、不重复、五索引 <ul>
<li>TreeSet自定义排序规则有几种方式<ul>
<li>方法一：javabean类实现Comparable接口，指定比较规则</li>
<li>方法二：创建集合时，自定义Comparator比较对象，指定比较规则</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h4><ul>
<li><p>特点</p>
<ul>
<li>双列集合一次需要存一对数据，分别为键和值</li>
<li>键不能重复，值可以重复</li>
<li>键和值是一一对应的，每一个键只能找到自己对应的值<ul>
<li>键+值这个整体我们称之为“键值对”或者“键值对对象”在java中叫做“Entry对象”</li>
</ul>
</li>
</ul>
<p>						</p>
</li>
<li><p>HashMap</p>
<ul>
<li><p>特点</p>
<ul>
<li>HashMap里面的一个实现类</li>
<li>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了</li>
<li>特点都是由键决定的：无序、不重复、无索引</li>
<li>HashMap跟HashSet底层原理一模一样的，都是哈希表结构</li>
</ul>
</li>
<li><p>HashMap基本方法</p>
<pre><code>  package Day.Api.map;
  
  import java.util.HashMap;
  import java.util.Map;
  
  /**
   * Created with IntelliJ IDEA.
   * creator: 蔡芳灿
   * Date: 2022/10/5
   * Time: 21:17
   * 需求：
   */
  public class MapTest &#123;
      public static void main(String[] args) &#123;
          Map&lt;String,String&gt; map= new HashMap&lt;&gt;();
          //添加元素
          //put方法的细节
          //添加/覆盖
          //在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中
          //在添加数据时候，如果键存在，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回
          map.put(&quot;cai&quot;,&quot;ss&quot;);
          map.put(&quot;ss&quot;,&quot;cai&quot;);
          System.out.println(map);
  
  
          //删除
          map.remove(&quot;ss&quot;);
          System.out.println(map);
  
          //判断集合中的键是否存在
          System.out.println(map.containsKey(&quot;cai&quot;));
          System.out.println(map.containsValue(&quot;ss&quot;));
  
          //判断集合的长度
          System.out.println(map.size());
  
  
  
          //清空集合
          map.clear();
          System.out.println(map);
          //判读集合是否为空
          System.out.println(map.isEmpty());
      &#125;
  
  &#125;
  
</code></pre>
</li>
<li><p>HashMap遍历方式</p>
<ul>
<li><pre><code>package Day.Api.map;

import java.util.*;
import java.util.function.BiConsumer;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/10/5
 * Time: 21:34
 * 需求：
 */
public class MapTestFor &#123;
    public static void main(String[] args) &#123;

        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;xiao&quot;,&quot;di&quot;);
        map.put(&quot;dd&quot;,&quot;cc&quot;);
        map.put(&quot;ll&quot;,&quot;jj&quot;);
        map.put(&quot;aa&quot;,&quot;bb&quot;);
        System.out.println(map);


        //


        //遍历键找值
        Set&lt;String&gt; m = map.keySet();
        for (String key : m) &#123;
//            System.out.println(key);
            String value = map.get(key);
//            System.out.println(key+&quot;=&quot;+value);
        &#125;



        //迭代器遍历
        Iterator&lt;String&gt; it = m.iterator();
        while (it.hasNext())&#123;
            String str = it.next();
            String s = map.get(str);
//            System.out.println(s);
        &#125;

        //Lambda表达式遍历
        m.forEach(s -&gt; System.out.println(s));


        System.out.println(&quot;-------------键值对遍历-----------------&quot;);

        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();
        for (Map.Entry&lt;String, String&gt; stringStringEntry : entrySet) &#123;
            System.out.println(stringStringEntry.getKey()+&quot;=&quot;+stringStringEntry.getValue());
        &#125;


        System.out.println(&quot;----------------Lambda遍历-------------&quot;);
        map.forEach(( key, value) -&gt; System.out.println(key+&quot;=&quot;+value));

    &#125;

&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>HashMap总结</p>
<ul>
<li>HashMap底层是哈希表结构</li>
<li>依赖于hashCode方法和equals方法保证键的唯一</li>
<li>如果键存储的是自定义对象，需要重写hashCode和equals方法</li>
<li>如果值存储自定义对象，不需要重写hashCode和equals方法</li>
</ul>
</li>
</ul>
</li>
</ul>

	</div>

	

	

	
</article>

	<div id="share_container">
	<div id="share" data-initialized="true">
		<a class="no-pjax icon-wechat" tooltip="分享到微信">
			<button class="btn btn-icon btn-success">
				<span class="btn-inner--icon"><i class="fa fa-weixin"></i></span>
			</button>
		</a>
		<a target="_blank" class="no-pjax icon-douban" tooltip="分享到豆瓣">
			<button class="btn btn-icon btn-primary" style="background: #209261;border: none;">
				豆
			</button>
		</a>
		<a target="_blank" class="no-pjax icon-qq" tooltip="分享到 QQ">
			<button class="btn btn-icon btn-primary" style="background: #2196f3;border: none;">
				<span class="btn-inner--icon"><i class="fa fa-qq"></i></span>
			</button>
		</a>
		<a target="_blank" class="no-pjax icon-qzone" tooltip="分享到 QQ 空间">
			<button class="btn btn-icon btn-primary" style="background: #ffc107;border: none;">
				<span class="btn-inner--icon"><i class="fa fa-star"></i></span>
			</button>
		</a>
		<a target="_blank" class="no-pjax icon-weibo" tooltip="分享到微博">
			<button class="btn btn-icon btn-warning">
				<span class="btn-inner--icon"><i class="fa fa-weibo"></i></span>
			</button>
		</a>
		<a target="_blank" class="no-pjax icon-facebook" tooltip="分享到 Facebook">
			<button class="btn btn-icon btn-primary" style="background: #283593;border: none;">
				<span class="btn-inner--icon"><i class="fa fa-facebook"></i></span>
			</button>
		</a>
		<a target="_blank" class="no-pjax icon-twitter" tooltip="分享到 Twitter">
			<button class="btn btn-icon btn-primary" style="background: #03a9f4;border: none;">
				<span class="btn-inner--icon"><i class="fa fa-twitter"></i></span>
			</button>
		</a>
		<a target="_blank" class="no-pjax icon-telegram" href="https://telegram.me/share/url?url=http://example.com/2022/12/16/JAVA/&text=java" tooltip="分享到 Telegram">
			<button class="btn btn-icon btn-primary" style="background: #42a5f5;border: none;">
				<span class="btn-inner--icon"><i class="fa fa-telegram"></i></span>
			</button>
		</a>
		<a target="_blank" class="no-pjax icon-copy-link" id="share_copy_link" tooltip="复制链接">
			<button class="btn btn-icon btn-default">
				<span class="btn-inner--icon"><i class="fa fa-link"></i></span>
			</button>
		</a>
	</div>
	<button id="share_show" class="btn btn-icon btn-primary" tooltip="分享">
		<span class="btn-inner--icon"><i class="fa fa-share"></i></span>
	</button>
</div>
<script type="text/javascript">
	socialShare("#share", {
	    title : 'java',
	    description : '–## 												JAVA
java之父—高斯林
Java的发展可以分为以下几个阶段：...',
	    wechatQrcodeTitle : "分享到微信",
	    wechatQrcodeHelper : '微信扫描二维码',
	    source : 'http://example.com/2022/12/16/JAVA/'
	});
	$("#share_show")[0].onclick = function(){
		$("#share_container").addClass("opened");
	};
	$("#share_copy_link")[0].onclick = function(){
		let input = document.createElement('input');
		document.body.appendChild(input);
		input.setAttribute("value", window.location.href);
		input.setAttribute("readonly", "readonly");
		input.setAttribute("style", "opacity: 0;mouse-events:none;");
		input.select();
		if (document.execCommand('copy')){
			iziToast.show({
				title: '链接已复制',
				message: "链接已复制到剪贴板",
				class: 'shadow',
				position: 'topRight',
				backgroundColor: '#2dce89',
				titleColor: '#ffffff',
				messageColor: '#ffffff',
				iconColor: '#ffffff',
				progressBarColor: '#ffffff',
				icon: 'fa fa-check',
				timeout: 5000
			});
		}else{
			iziToast.show({
				title: '复制失败',
				message: "请手动复制链接",
				class: 'shadow',
				position: 'topRight',
				backgroundColor: '#f5365c',
				titleColor: '#ffffff',
				messageColor: '#ffffff',
				iconColor: '#ffffff',
				progressBarColor: '#ffffff',
				icon: 'fa fa-close',
				timeout: 5000
			});
		}
		document.body.removeChild(input);
	};
</script>


	<div id="post_comment" class="card shadow-sm">
		<div id="gitalk-container"></div>
<script type="text/javascript">
	var gitalk = new Gitalk({
		clientID: '937043aa292125133049',
		clientSecret: '72cf8c7d49fc45722fb79e78d416058ad4f70b90',
		repo: 'blog-comments',
		owner: 'csh1311',
		admin: ['csh1311'],
		id: location.pathname,
		distractionFreeMode: false
	})
	gitalk.render('gitalk-container');
</script>

	</div>




<div class="post-navigation card shadow-sm"><div class="post-navigation-item post-navigation-pre"><span class="page-navigation-extra-text"><i class="fa fa-arrow-circle-o-left" aria-hidden="true"></i>上一篇</span><a href="/2022/12/16/go/" rel="prev"> go</a></div><div class="post-navigation-item post-navigation-next"><span class="page-navigation-extra-text">下一篇 <i class="fa fa-arrow-circle-o-right" aria-hidden="true"></i></span><a href="/2022/11/21/docker-django/" rel="next"> docker-django</a></div></div>




		
		
		
		

					<footer id="footer" class="site-footer card shadow-sm border-0">
						
						<div>Theme <a target="_blank" rel="noopener" href="https://github.com/solstice23/hexo-theme-argon"><strong>Argon</strong></a> | Powered by Hexo</div>
						<span id="busuanzi_container_site_uv">
							本站访客数 <span id="busuanzi_value_site_uv"></span> 人次
						</span>
					</footer>
				</main>
			</div>
		</div>
		
<script src="/argontheme.js"></script>

		
		
		

		
			<script>
				var argonEnableCodeHighlight = true;
			</script>
			
<link rel="stylesheet" href="/assets/vendor/highlight/styles/vs2015.css">

		

	</div>
</div>
<noscript>
	<style>
		article img.lazyload[src^="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPg"]{display: none;}
		.comment-item-text .comment-sticker.lazyload{display: none;}
	</style>
</noscript>
</body>



</html>

