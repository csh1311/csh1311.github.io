<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Hexo
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            java
        </p>
        <hr>
    </div>
    <div >
        <div class="post-content"  >
            <p>–## 												JAVA</p>
<ol>
<li><p>JDK是什么？有哪些内容组成？</p>
<p>​           JDK是java开发工具包</p>
<ul>
<li>​	JVM虚拟机：java程序运行的地方</li>
<li>核心类库：java已经写好的东西，我们可以直接用。</li>
<li>开发工具：javac、java、jdb、jhat</li>
</ul>
</li>
<li><p>JRE是什么？有哪些内容组成？</p>
<p>JRE是java运行环境</p>
<p>JVM、核心类库、运行工具</p>
</li>
<li><p>JDk、JRE、JVM三者包含关系</p>
<ul>
<li>JDK包含JRE</li>
<li>JRE包含JVM</li>
</ul>
</li>
</ol>
<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul>
<li>在ACIIL表中字符’1’对应的数字是49，字符’0’对应的字符是48，这两个字符’1’-‘0’等于数字1</li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>隐式转换小结</p>
<ol>
<li><p>取值范围</p>
<p>byte&lt;short&lt;int&lt;long&lt;float&lt;double</p>
</li>
<li><p>什么时候转换</p>
<p>数据类型不一样，不能计算，需要转成一样的数据类型才可以计算</p>
</li>
<li><p>转换规则1：</p>
<p>取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算</p>
</li>
<li><p>转换规则2</p>
<p>byte short char 三种类型的数据在运算的时候，都会直接先提升到int，然后再进行运算</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220919165559479.png" alt="image-20220919165559479"></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>数组定义</p>
<ul>
<li>数据类型[]   数组名 &#x3D;  new 数据类型[]{元素1，元素2，元素3}</li>
<li>数据类型[]  数组名 &#x3D; {}</li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        定义数组存储5个学生年龄</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">15</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">13</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] ar1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">15</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">13</span>&#125;;</span><br><span class="line">        System.out.println(arr);  <span class="comment">//[I@1b6d3586</span></span><br><span class="line">        System.out.println(ar1);  <span class="comment">//[I@4554617c</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//扩展</span></span><br><span class="line">        <span class="comment">//解释数组的地址值  //[I@1b6d3586</span></span><br><span class="line">        <span class="comment">//[ : 表示当前是一个数组</span></span><br><span class="line">        <span class="comment">//I ： 表示当前数组里面的元素都是int类型</span></span><br><span class="line">        <span class="comment">//@ ： 表示一个间隔符。固定格式</span></span><br><span class="line">        <span class="comment">//1b6d3586：才是数组真正的地址。（十六进制）</span></span><br><span class="line">        <span class="comment">//平时会把整个叫做数组地址值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>java内存分配</p>
<ul>
<li>java运行是虚拟机也会占用内存，但是为了更好的利用这块内存，虚拟机又分配了5个部分，每个部分都有它自己的作用</li>
</ul>
<p>​     <img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902133323410.png" alt="image-20220902133323410" style="zoom:67%;" /></p>
<ul>
<li>jdk7以前方法区和堆是连在一起的</li>
</ul>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902162900225.png" alt="image-20220902162900225" style="zoom:67%;" />

<ul>
<li><p>注意：从jdk8开始取消了方法区，新增了元空间。把原来方法区的多种功能进行拆分，有的功能放在队中有的功能放在元空间中</p>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902163809082.png" alt="image-20220902163809082" style="zoom:67%;" /></li>
</ul>
</li>
<li><ul>
<li>栈   方法运行使用的内存，比如main方法运行，进入栈内存中</li>
<li>堆   存储对象或数组，只要new来创建的都进入堆内存中</li>
<li>方法区   存储可以运行class文件</li>
<li>本地方法栈   jvm使用操作系统的功能是使用，与开发无关</li>
<li>寄存器  给cpu使用，与开发无关</li>
</ul>
</li>
<li><p>数组内存分配</p>
<ul>
<li><p>只要是new出来的一定是在堆里面开辟一个小空间</p>
</li>
<li><p>如歌new了多次，那么堆里就有多少个小空间，而且每个小空间都有各自的数据</p>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902165249568.png" alt="image-20220902165249568" style="zoom:67%;" />
</li>
<li><p>当两个数组指向同一个空间的，其中一个数组对空间数据中的值发生改变，那么其他数据再次访问的时候都是修改之后的结果</p>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902165249568.png" alt="image-20220902165249568" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>什么是方法</p>
<p>方法是程序中最小的执行单元</p>
<ol>
<li><p>实际开发中，什么时候用到方法？</p>
<p>​	重复的代码，具有独立功能的代码可以抽到方法中</p>
</li>
<li><p>实际开发中，方法有什么好处</p>
</li>
</ol>
<p>​            提高代码的复用性</p>
<p>​			提高代码的维护</p>
</li>
<li><p>方法的格式</p>
<ul>
<li><p>最简单的方法定义</p>
<ul>
<li>方法的定义</li>
</ul>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902171840717.png" alt="image-20220902171840717" style="zoom:67%;" />

<ul>
<li><p>方法的调用</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902172119284.png" alt="image-20220902172119284"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Day04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//方法的调用</span></span><br><span class="line">        playGame();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 练习</span></span><br><span class="line"><span class="comment">         *定义一个方法，在方法中定义两个变量进行求和</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意：定义方法是在main主方法外面，但是方法的调用在主方法里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//定义一个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;确定&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个求和的方法</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a+b;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>带参数的方法定义</p>
<ul>
<li><p>带参数方法的定义</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902210944199.png" alt="image-20220902210944199"></p>
</li>
<li><p>带参数方法发调用</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902211057405.png" alt="image-20220902211057405"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li><p>形参和实参</p>
<ul>
<li><p>形参：全称形式参数，是指方法定义中的参数</p>
</li>
<li><p>实参：全称实际参数，是指调用的参数</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902211724508.png" alt="image-20220902211724508"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //调用求长方形的周长，将结果在方法中进行</span><br><span class="line">    rectangle(5.5,6.5);</span><br><span class="line">      </span><br><span class="line">    //调用求圆的面积，将结果在方法中打印</span><br><span class="line">    circle(4.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    //定义一个长方形周长方法</span><br><span class="line">public static void rectangle(double len,double width)&#123;</span><br><span class="line">    double result = (len+width)*2;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">//定义一个求圆的面积</span><br><span class="line">public static void circle(double r)&#123;</span><br><span class="line">    double S = 3.14*(r*r);</span><br><span class="line">    System.out.println(S);</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>带返回值的方法定义</p>
<ul>
<li><p>带返回值方法的定义</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220902220113515.png" alt="image-20220902220113515"></p>
</li>
<li><p>带返回值方法的调用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //调用长方形面积</span><br><span class="line">    double are = getAre(3.0, 4.0);</span><br><span class="line">    double are1 = getAre(4.0, 3.0);</span><br><span class="line">    if (are &gt; are1)&#123;</span><br><span class="line">        System.out.println(&quot;第一个长方形面积大于第二个长方形面积&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        System.out.println(&quot;第二个长方形面积大于第一个长方形面积&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义一个求长方形面积的方法</span><br><span class="line">public  static double getAre(double len,double width)&#123;</span><br><span class="line">    double res = len*width;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法的注意事项<ul>
<li>方法不调用就不执行</li>
<li>方法与方法之间是平级关系，不能互相嵌套</li>
<li>方法的编写顺序和执行顺序无关，根据方法调用顺序有关</li>
<li>方法的返回值类型为void，表示该方法没有返回值，没有返回值的方法可以省略return语句不写。如果要编写编写return，后面不能跟具体的数据。</li>
<li>return语句下面，不能编写代码，因为永远执行不到，属于无效代码</li>
</ul>
</li>
<li>return关键字<ul>
<li>方法没有返回值：可以省略不写。如果书写，表示结束方法</li>
<li>方法有返回值：必须要写。表示结束方法和返回结果是</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方法的重载</p>
<ul>
<li><p>什么是方法的重载</p>
<ul>
<li>在同一个类中，定义了多个同名的方法，这些同名的方法具有同种的功能</li>
<li>每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系</li>
</ul>
<p>简单机：同一个类中，方法名相同参数不同的方法。与返回值无关</p>
<p>​				参数不同：个数不同、类型不同、顺序不同</p>
</li>
</ul>
</li>
<li><p>方法的内存</p>
<ul>
<li>方法调用的基本内存原理</li>
<li>方法传递基本数据类型原理<ul>
<li>基本数据类型：变量存储的都是真是数据<ul>
<li>整数类型</li>
<li>浮点数类型</li>
<li>布尔类型</li>
<li>字符类型</li>
</ul>
</li>
<li>引用数据类型：在栈内记录的是地址值，使用其他空间的数据<ul>
<li>除了上面基本数据类型都是</li>
</ul>
</li>
</ul>
</li>
<li>方法传递引用数据类型的内存原理</li>
</ul>
</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li><p>设计对象并使用</p>
<ul>
<li><p>类和对象： 必须先设计类才能获取对象</p>
<ul>
<li>类（设计图）:是对象共同特征的描述</li>
<li>对象：是真实存在的具体东西</li>
</ul>
</li>
<li><p>类的几个注意事项</p>
<ul>
<li>用来描述一类事物的类，专业叫做：javabean类。在javabean类中，是不写mian方法的。</li>
<li>在以前。编写mian方法的类，叫做测试类。我们可以在测试类中创建Javabean类对象并进行赋值调用。</li>
</ul>
</li>
<li><p>总结</p>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904100155619.png" alt="image-20220904100155619" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904100217142.png" alt="image-20220904100217142" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>封装</p>
<p>- </p>
</li>
<li><p>this关键字</p>
<ul>
<li>可以区别成员变量和局部变量</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>作用：<ul>
<li>创建对象的时候，由虚拟机自动调用，给成员变量进行初始化的。</li>
</ul>
</li>
<li>特点：<ul>
<li>方法名与类名相同，大小写也要一致</li>
<li>没有返回值类型，连void都没有</li>
<li>没有具体的返回值（不能由retrun带回结果的数据）</li>
</ul>
</li>
<li>构造方法有几种，各自的作用是什么。<ul>
<li>无参数构造方法：初始化对象是，成员变量的数据均采用默认值。</li>
<li>有参数构造方法：在初始对象时候，同时可以为对象进行赋值。</li>
</ul>
</li>
<li>执行时机<ul>
<li>创建对象的时候由虚拟机调用，不能手动调用构造方法</li>
<li>每创建一次对象，就会调用一次构造方法</li>
</ul>
</li>
<li>构造方法定义<ul>
<li>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</li>
<li>如果定义构造方法，系统将不再提供默认的构造方法</li>
</ul>
</li>
<li>构造方法的重载<ul>
<li>带参构造方法，和无参构造方法，两者方法名相同但是参数不同，这叫做构造方法的重载</li>
</ul>
</li>
<li>推荐的使用方式<ul>
<li>无论是否使用，都手动书写无参数构造的方法，和带全部参数的构造方法</li>
</ul>
</li>
<li>构造方法有哪些注意事项<ul>
<li>任何类定义出来，默认自带了无参数构造器，写不写都有。</li>
<li>一旦定义了有参数构造器，无参数构造器就没有了，此时就需要自己写无参数构造器了。</li>
<li>建议在任何时候都手动写上空参和带全部参数的构造方法</li>
</ul>
</li>
</ul>
</li>
<li><p>标准javaBean</p>
<ul>
<li>类名需要见名知意</li>
<li>成员变量使用private修饰</li>
<li>提供至少两个构造方法、<ul>
<li>无参构造方法</li>
<li>有参构造方法</li>
</ul>
</li>
<li>成员方法<ul>
<li>提供每一个成员变量对应的setXxx()&#x2F;getXxx()</li>
<li>如果还要其他行为，也需要写上</li>
</ul>
</li>
</ul>
</li>
<li><p>对象内存图</p>
<ul>
<li><p>一个对象的内存图</p>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904110844634.png" alt="image-20220904110844634" style="zoom: 50%;" />
</li>
<li><p>多个对象的内存图</p>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904111831605.png" alt="image-20220904111831605" style="zoom: 50%;" />
</li>
<li><p>两个引用指向同一个对象的内存图</p>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904111856074.png" alt="image-20220904111856074" style="zoom:50%;" />
</li>
<li><p>this的内存图原理</p>
<ul>
<li>this的作用:区分局部变量和成员变量</li>
<li>this的本质：所在方法调用者的地址值</li>
</ul>
</li>
<li><p>基本数据类型和引用数据类型的区别</p>
</li>
<li><p>局部变量和成员变量的区别</p>
</li>
</ul>
</li>
<li><p>补充知识：成员变量、局部变量区别</p>
<ul>
<li>成员变量：类中方法外的变量</li>
<li>局部变量：类中方法内的变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220904162404297.png" alt="image-20220904162404297"></p>
</li>
<li><p>修饰符</p>
<ul>
<li>private<ul>
<li>是一个权限修饰符</li>
<li>可以修饰成员（成员变量和成员方法）</li>
<li>被private修饰的成员只能在本类中才能访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>练习</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Day.dayMxdx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个长度为3的数组，数组存储1~3名学生对象作为初始化数据，学生对象的学号，姓名各不相同。</span></span><br><span class="line"><span class="comment"> * 学生属性：学号，姓名，年龄</span></span><br><span class="line"><span class="comment"> * 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一判断</span></span><br><span class="line"><span class="comment"> * 要求二：添加完毕之后遍历所有学生信息</span></span><br><span class="line"><span class="comment"> * 要求三：通过id删除，如果不存在，则提示删除失败</span></span><br><span class="line"><span class="comment"> * 要求四：删除后遍历所有学生信息</span></span><br><span class="line"><span class="comment"> * 要求五：查询数组id为“heima002”的学生，如果存在，则将他年龄+1；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Day.dayMxdx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个长度为3的数组，数组存储1~3名学生对象作为初始化数据，学生对象的学号，姓名各不相同。</span></span><br><span class="line"><span class="comment"> * 学生属性：学号，姓名，年龄</span></span><br><span class="line"><span class="comment"> * 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一判断</span></span><br><span class="line"><span class="comment"> * 要求二：添加完毕之后遍历所有学生信息</span></span><br><span class="line"><span class="comment"> * 要求三：通过id删除，如果不存在，则提示删除失败</span></span><br><span class="line"><span class="comment"> * 要求四：删除后遍历所有学生信息</span></span><br><span class="line"><span class="comment"> * 要求五：查询数组id为“heima002”的学生，如果存在，则将他年龄+1；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个长度为3的数组</span></span><br><span class="line">        Student[] arr = <span class="keyword">new</span>  <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;001&quot;</span>,<span class="string">&quot;小明&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;小东&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;003&quot;</span>,<span class="string">&quot;小蔡&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        <span class="comment">//数组存储1~3名学生对象作为初始化数据</span></span><br><span class="line">        arr[<span class="number">0</span>] = s1;</span><br><span class="line">        arr[<span class="number">1</span>] = s2;</span><br><span class="line">        arr[<span class="number">2</span>] = s3;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次添加一个对象到数组里面</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;004&quot;</span>,<span class="string">&quot;小第&quot;</span>,<span class="number">28</span>);</span><br><span class="line"><span class="comment">//        调用判断方法</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> repetition(arr, s4.getId());</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组里面已经存在id，请重新跟换id在添加&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getCount(arr);</span><br><span class="line">            <span class="comment">//如果相等则数组长度不够</span></span><br><span class="line">            <span class="keyword">if</span> (count==arr.length)&#123;</span><br><span class="line">                <span class="comment">//重新创建数组</span></span><br><span class="line">                Student[] createArr = createArr(arr);</span><br><span class="line">                createArr[count] = s4;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; createArr.length; i++) &#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> createArr[i];</span><br><span class="line">                    System.out.println(student.getId()+<span class="string">&quot;,&quot;</span>+student.getName()+<span class="string">&quot;,&quot;</span>+student.getAge());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arr[count] = s4;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据id删除</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getId(arr, <span class="string">&quot;002&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组没有这个id，删除失败&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Student[] students = deleteArray(arr,index);</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">                <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> students[i];</span><br><span class="line">                System.out.println(student.getId()+<span class="string">&quot;,&quot;</span>+student.getName()+<span class="string">&quot;,&quot;</span>+student.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查询数组id为“heima002”的学生，如果存在，则将他年龄+1</span></span><br><span class="line">        <span class="comment">//根据id删除</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">indexs</span> <span class="operator">=</span> getId(arr, <span class="string">&quot;003&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (indexs == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组没有这个id&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> arr[indexs];</span><br><span class="line">            System.out.println(student.getId()+<span class="string">&quot;,&quot;</span>+student.getName()+<span class="string">&quot;,&quot;</span>+(student.getAge()+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法判断数组数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(Student[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (arr[i]!=<span class="literal">null</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，判断数组里面是否有重复的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boolean  <span class="title function_">repetition</span><span class="params">(Student[] arr, String id)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="keyword">if</span> (student.getId()==id)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个如果数组长度不够，重新创建数组，然后数组长度等于旧数组的长度+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Student[]  createArr(Student[] arr)&#123;</span><br><span class="line">        Student[] createArr = <span class="keyword">new</span> <span class="title class_">Student</span>[arr.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            createArr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法根据id查询出索引的位置</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">int</span> <span class="title function_">getId</span><span class="params">(Student[] arr, String id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="keyword">if</span> (s.getId()==id)&#123;</span><br><span class="line">                count = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法删除数组元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Student[] deleteArray(Student[] arr,<span class="type">int</span> index)&#123;</span><br><span class="line">        Student[] newArray = <span class="keyword">new</span>  <span class="title class_">Student</span>[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index &gt; arr.length)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数组越界&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;index)&#123;</span><br><span class="line">                newArray[i] = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                newArray[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(newArray.length);</span><br><span class="line">        <span class="keyword">return</span>  newArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="API和API文档"><a href="#API和API文档" class="headerlink" title="API和API文档"></a>API和API文档</h4><ul>
<li><p>API文档：应用程序编程接口</p>
<ul>
<li>简单理解：API就是别人已经写好的东西，我们不需要自己编写，直接使用即可</li>
</ul>
</li>
<li><p>Java API：指的就是JDK中提供的各种功能的java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。</p>
</li>
<li><p>String</p>
<ul>
<li><p>字符串的内容是不会发生改变的，它的对象创建后不能被更改</p>
</li>
<li><p>创建String对象的两种方式</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145255890.png" alt="image-20220907145255890"></p>
</li>
<li><p>String内存模型</p>
<ul>
<li><p>当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。</p>
<ul>
<li>不存在：创新的</li>
<li>存在：复用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145634099.png" alt="image-20220907145634099"></p>
</li>
<li><p>当使用new创建赋值是</p>
<ul>
<li>每new一个就会在堆里面创建小空间，不会使用Strin Table(串池)，这样会大量的使用内存</li>
</ul>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907145839923.png" alt="image-20220907145839923"></p>
</li>
<li><p>字符串之间比较</p>
<ul>
<li><p>第一个方式创建和第二个方式new出来的用&#x3D;&#x3D;于比较是等于false，因为它们比较的是地址值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;dasdadas&quot;</span>;    <span class="comment">//进入内存的串池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span>  <span class="string">&quot;dasdadas&quot;</span>;</span><br><span class="line"> System.out.println(name==names);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"> <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;dasdadas&quot;</span>);   <span class="comment">//直接在堆空间中生成小空间</span></span><br><span class="line">        System.out.println(name==n);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//字符串比较</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">equals</span> <span class="operator">=</span> n.equals(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;equals:&quot;</span>+equals);   <span class="comment">//true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">equal</span> <span class="operator">=</span> n.equals(names);</span><br><span class="line">        System.out.println(<span class="string">&quot;equal:&quot;</span>+equal);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串忽略大小写比较</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> s.equalsIgnoreCase(s1);</span><br><span class="line">        System.out.println(b);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Boolean equals 方法（要比较的字符串）                  完全一样结果是true，否则为false</p>
</li>
<li><p>Boolean equalslgnoreCase（要比较的字符串）       忽略大小写的比较</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>StringBuilder</p>
<ul>
<li><p>可以看成是一个容器，创建之后内容是可以改变的</p>
</li>
<li><p>StringBuilder常用方法</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220907231629383.png" alt="image-20220907231629383"></p>
</li>
<li><p>使用StringBuilder的场景</p>
<ul>
<li>字符串拼接</li>
<li>字符串的反转</li>
</ul>
</li>
</ul>
</li>
<li><p>StringJoiner</p>
<ul>
<li>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的</li>
<li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用</li>
<li>JDK8才出现的</li>
</ul>
</li>
<li><p>字符串原理</p>
<ul>
<li>&#x3D;&#x3D;号比较的到底是什么？<ul>
<li>基本数据类型比较数组值</li>
<li>引用数据类型比较地址值</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串拼接的底层原理</p>
<ul>
<li>如果很多字符串变量拼接，不要直接+。在底层会创建多个对象，浪费时间，浪费性能。</li>
<li>如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串</li>
<li>如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存</li>
</ul>
</li>
<li><p>StringBuilder底层原理</p>
<ul>
<li>所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存</li>
</ul>
</li>
<li><p>ArrayList集合</p>
<ul>
<li>长度可以变</li>
<li>集合不能直接存储基本数据类型</li>
</ul>
</li>
<li><p>static（静态）</p>
<ul>
<li>static表示静态，是java中的修饰符，可以修饰成员方法，成员变量</li>
<li>被static修饰的成员变量，叫做静态变量<ul>
<li>特点：<ul>
<li>被该类所有对象共享</li>
<li>不属于对象，属于类</li>
<li>随着类的加载而加载，优先于对象存在</li>
</ul>
</li>
<li>调用方法：<ul>
<li>类名调用</li>
<li>对象名调用</li>
</ul>
</li>
</ul>
</li>
<li>被static修饰的成员方法，叫做静态方法<ul>
<li><p>特点</p>
<ul>
<li>多用在测试类和工具类</li>
<li>javabean类中很少会用</li>
</ul>
</li>
<li><p>调用方法</p>
<ul>
<li>类名调用</li>
<li>对象名调用</li>
</ul>
</li>
</ul>
</li>
<li>工具类<ul>
<li>类名见名之义</li>
<li>私有化构造方法</li>
<li>方法都定义为静态方法，方便调用</li>
</ul>
</li>
<li>static的注意事项<ul>
<li>静态方法只能访问静态变量和静态方法</li>
<li>非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和静态的成员方法</li>
<li>静态方法中是没有this关键字</li>
</ul>
</li>
<li>总结：<ul>
<li>静态方法中，只能访问静态。</li>
<li>非静态方法可以访问所有。</li>
<li>静态方法中没有this关键字</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p>java中提供一个关键字extedns</p>
</li>
<li><p>当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码</p>
</li>
<li><p>什么是继承、继承的好处？</p>
<ul>
<li>继承是面向对象的三大特征之一，可以让类跟类之间产生子父的关系</li>
<li>可以把多个子类中重复的代码抽取到父类中，子类可以使用，减少代码冗余，提高代码的复用性</li>
</ul>
</li>
<li><p>继承的格式？</p>
<ul>
<li>public class 子类 extedns 父类 {}</li>
</ul>
</li>
<li><p>继承后子类的特点？</p>
<ul>
<li>子类可以得到父类的属性和行为，子类可以使用。</li>
<li>子类可以在父类的基础上新增其他功能子类更强大</li>
</ul>
</li>
<li><p>子类到底能继承父类中的哪些内容？（内存图&#x2F;内存分析工具）</p>
<img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220911173759076.png" alt="image-20220911173759076" style="zoom:50%;" />
</li>
<li><p>继承的特点</p>
<ul>
<li>java只支持单继承，不支持多继承，但支持多层继承。<ul>
<li>一个子类只能继承一个父类，子类不能同时继承多个父类，子类A继承父类B，父类B可以继承父类C。</li>
</ul>
</li>
</ul>
</li>
<li><p>继承中：成员变量的访问特点</p>
<ul>
<li><p>就近原则：谁离我近，我就用随</p>
<ul>
<li>先在局部位置找，本类成员位置找，父类成员位置找，逐级往上</li>
</ul>
</li>
<li><p>如歌出现了重名的成员变量怎么办吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(name);</span><br><span class="line">System.out.println(<span class="built_in">this</span>.name); </span><br><span class="line">System.out.println(<span class="built_in">super</span>.name); <span class="comment">//去找父类的name</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>继承中：成员方法的访问特点</p>
</li>
<li><p>继承中：构造方法的访问特点</p>
<ul>
<li>父类中的构造方法不会被子类继承，但是可以通过super来调用</li>
<li>子类构造方法的第一行，有一个默认的super();</li>
<li>默认先访问父类中无参的构造方法，在执行自己</li>
<li>如果想要方法文父类有参构造方法，必须手动书写。</li>
<li>子类中所有的构造方法默认先访问父类中的无参构造，在执行自己</li>
</ul>
</li>
</ul>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul>
<li>方法的重写<ul>
<li>当父类的方法不能满足子类现在的需求时，需要进行方法的重写</li>
<li>重写方法的名称、形参列表必须与父类一致</li>
<li>子类重写父类方法时，访问权限子类必须大于等于父类（暂时了解：空着不写&lt;protected&lt;public)</li>
<li>子类重写父类的方法时，返回值类型子类必须小于父类</li>
<li>只有被添加到虚方法表中的方法才能被重写</li>
</ul>
</li>
<li>书写格式<ul>
<li>在继承体系中，子类出现了和父类中一模一样的方法声明，我们称子类这个方法是重写的方法</li>
</ul>
</li>
<li>@Override重写的注解<ul>
<li>@Override是放在重写后的方法上，校验子类重写是语法是否正确</li>
<li>加上注解后如果有红色波浪线，表示语法错误</li>
<li>建议重写方法都加上@Override注解，代码安全，优雅</li>
</ul>
</li>
</ul>
<h4 id="this，super"><a href="#this，super" class="headerlink" title="this，super()"></a>this，super()</h4><ul>
<li>this:理解为一个变量，表示当前方法调用者的地址值；</li>
<li>super:代表父类存储空间。</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220912094526173.png" alt="image-20220912094526173">多态</h4><ul>
<li><p>​	什么是多态？</p>
<ul>
<li>同类型的对象，表现出的不同的形态</li>
</ul>
</li>
<li><p>​	多态的表现形式</p>
<ul>
<li>父类类型 对象名称 &#x3D; 子类对象；</li>
</ul>
</li>
<li><p>多态的前提</p>
<ul>
<li>有继承关系</li>
<li>有父类引用指向子类对象</li>
<li>有方法重写</li>
</ul>
</li>
<li><p>多态的好处？</p>
<ul>
<li>使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利</li>
</ul>
</li>
<li><p>多态调用成员的特点</p>
<ul>
<li>变量调用:编译看左边，运行看右边。</li>
<li>方法调用：编译看左边，运行看右边。</li>
</ul>
</li>
<li><p>多态的优势</p>
<ul>
<li>方法中，使用父类型作为参数，可以接受所有子类对象</li>
</ul>
</li>
<li><p>多态的弊端是什么？</p>
<ul>
<li>不能使用子类的特有功能</li>
</ul>
</li>
<li><p>引用数据类型的类型转换，有几种方式？</p>
<ul>
<li>自动类型转换，强制类型转换</li>
</ul>
</li>
<li><p>强制类型转换能解决什么问题？</p>
<ul>
<li>可以转换成真正的子类型类型，从而调用子类独有功能</li>
<li>转换类型与真实对象类型不一致会报错</li>
<li>转换的时候用instanceof关键字进行判断</li>
</ul>
</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>​	使用final修饰之后是不能改变的</p>
<ul>
<li>方法 表面该方法最终方法，不能被重写</li>
<li>类instanceof表面该类是最终类，不能被继承</li>
<li>变量 叫做常量，只能被赋值一次</li>
<li>final修饰变量：是常量，不能修改<ul>
<li>基本数据类型：变量的值不能修改</li>
<li>引用数据类型：地址值不能修改但是内部的属性值可以修改</li>
</ul>
</li>
</ul>
<p>使用场景</p>
<ul>
<li>​	一些系统不可被修改的常量</li>
</ul>
<h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><ul>
<li><p>private ： 私有的，只能 自己用</p>
</li>
<li><p>默认 ： 只能在本包里面用</p>
</li>
<li><p>protected ： 受保护的</p>
</li>
<li><p>public ： 公共的</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220912153212668.png" alt="image-20220912153212668"></p>
</li>
</ul>
<ol>
<li>构造代码块<ol>
<li>写在成员位置的代码块</li>
<li>作用：可以把多个构造方法中重复的代码抽取出来</li>
<li>执行时机：我们在创建本类对象的时候会执行构造代码块再执行构造方法</li>
</ol>
</li>
<li>静态代码块<ol>
<li>格式：static{}</li>
<li>数据的初始化（重点）</li>
<li>执行时机：随着类的加载而加载的，并且只执行一次</li>
</ol>
</li>
</ol>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>抽象类<ul>
<li>public abstract class 类名{}</li>
<li>如果一个<u>类中存在抽象方法</u>，那么这个类就<u>必须声明为抽象类</u></li>
</ul>
</li>
<li>抽象方法<ul>
<li>格式:public abstract 返回值类型 方法名（参数列表）；</li>
<li>抽象方法：将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容不一样，所以，再父类中不能确定具体的方法体。该方法就可以定义为抽象方法。</li>
</ul>
</li>
<li>子类继承抽象类之后，如何重写抽象方法</li>
<li>抽象类和抽象方法注意事项<ul>
<li>抽象类不能实例化（抽象类不能创建对象）</li>
<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>
<li>可以有构造方法</li>
<li>抽象的子类<ul>
<li>要么重写抽象类中的所有抽象方法</li>
<li>要么是抽象类</li>
</ul>
</li>
</ul>
</li>
<li>抽象类的作用是声明样的？<ul>
<li>抽取共性时，无法确定方法体，就把方法定义为抽象的，强制让子类按照某种格式重写。</li>
</ul>
</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li>接口：就是一种规则</li>
<li>接口的定义和使用<ul>
<li>接口用关键字interface来定义<ul>
<li>public interface 接口名{}</li>
</ul>
</li>
<li>接口不能实例化</li>
<li>接口和类之间是实现关系，通过implements关键字表示<ul>
<li>public class 类名implement 接口名 {}</li>
</ul>
</li>
<li>接口的子类（实现类）<ul>
<li>要么重写接口中的所有抽象方法</li>
<li>要么是抽象类</li>
</ul>
</li>
</ul>
</li>
<li>接口成员的特点<ul>
<li>成员变量<ul>
<li>只能是常量</li>
<li>默认修饰符：public static final</li>
</ul>
</li>
<li>没有构造方法</li>
<li>成员方法<ul>
<li>只能是抽象方法</li>
<li>默认修饰符：public abstract</li>
</ul>
</li>
<li>jdk7以前：接口只能定义抽象方法</li>
</ul>
</li>
<li>接口和类之间的关系<ul>
<li>类和类之间的关系<ul>
<li>继承关系，只能单继承，不能多继承，但是可以多层继承</li>
</ul>
</li>
<li>类和接口的关系<ul>
<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>
</ul>
</li>
<li>接口和接口的关系<ul>
<li>继承关系，可以单继承，也可以多继承</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul>
<li><p>类的五大成员：</p>
<ul>
<li>属性，方法，构造方法、代码块、内部类</li>
</ul>
</li>
<li><p>内部类的分类</p>
<ul>
<li><p>成员内部类</p>
<ul>
<li><p>写在成员位置，属于外部类的一员</p>
</li>
<li><p>成员内部类可以被修饰符所修饰</p>
</li>
<li><p>在成员内部类里面，JDK16之前不能定义静态变量，JDK16才开始可以定义静态变量</p>
</li>
<li><p>调用格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Day;</span><br><span class="line"></span><br><span class="line">public class Day06Test &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">//        创建内部类对象</span><br><span class="line">        Day06.Engine  e= new Day06().new Engine();</span><br><span class="line">        e.show();</span><br><span class="line">        //创建内部类对象,在外部类创建一个成员方法来调用内部类的对象</span><br><span class="line">        Day06 d = new Day06();</span><br><span class="line">        Day06.Engine engine = d.getEngine();</span><br><span class="line">        engine.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>静态内部类</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220914224011897.png" alt="image-20220914224011897"></p>
</li>
<li><p>局部内部类</p>
<ul>
<li>将内部类定义在方法里面就叫做局部内部类，类似于方法的局部变量</li>
<li>外界是无法直接使用，需要在方法内部创建对象并使用</li>
<li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li>
</ul>
</li>
<li><p>匿名内部类</p>
<ul>
<li>内部类本质上就是隐藏了名字的内部类</li>
<li>定义格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或者接口名()&#123;      //如歌类名是类那么就是继承关系，如果是接口名那么就是实现接口</span><br><span class="line">	重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>什么是内部类</p>
<ul>
<li>在一个类中，再定义一个类</li>
</ul>
</li>
<li><p>内部类的访问特点</p>
<ul>
<li><p>内部类可以直接访问外部类的成员，包括私有</p>
</li>
<li><p>外部类要访问内部类的成员，必须创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package Day;</span><br><span class="line"></span><br><span class="line">public class Day06 &#123;</span><br><span class="line">    String carName;</span><br><span class="line">    int carAGe;</span><br><span class="line">    String carColor;</span><br><span class="line"> 	int a = 30;</span><br><span class="line"></span><br><span class="line">    //定义一个外部类的方法</span><br><span class="line">    public  void  shows()&#123;</span><br><span class="line">        //外部类访问成员变量</span><br><span class="line">        System.out.println(carAGe);</span><br><span class="line">        //外部类访问不了内部类的成员变量</span><br><span class="line">//        System.out.println(engineAgge);</span><br><span class="line">        //外部类访问不了内部类的成员方法</span><br><span class="line">//        show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //定义一个内部类</span><br><span class="line">    class Engine&#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        int engineAgge;</span><br><span class="line">        int a = 10;</span><br><span class="line"></span><br><span class="line">        //定义一个内部类的方法</span><br><span class="line">        public void show()&#123;</span><br><span class="line">         	int a = 20;</span><br><span class="line">            //内部类访问内部类的成员变量</span><br><span class="line">            System.out.println(engineName);</span><br><span class="line">            //内部类访问外部类的成员变量</span><br><span class="line">            System.out.println(carName);</span><br><span class="line">            //内部类访问外部类的成员方法</span><br><span class="line">            shows();</span><br><span class="line">            //如果内部类和外部类的成员变量同名需要以下方法调用</span><br><span class="line">             System.out.println(a);//20</span><br><span class="line">             System.out.println(this.a);  //10</span><br><span class="line">             System.out.println(Day06.this.a);//30</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package math;</span><br><span class="line"></span><br><span class="line">public class MathTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float a = 314554.88f;</span><br><span class="line">        int round = Math.round(a);</span><br><span class="line">        System.out.println(round);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //返回绝对值</span><br><span class="line">        int b = -100;</span><br><span class="line">        int abs = Math.abs(b);</span><br><span class="line">        System.out.println(abs);</span><br><span class="line"></span><br><span class="line">        //返回两个数的总数 如果数据超出int范围会抛出异常</span><br><span class="line">        int x = 2, y = 10;</span><br><span class="line">        int i = Math.addExact(x, y);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        //返回乘数的乘积</span><br><span class="line"></span><br><span class="line">        //比较两个数的最大值</span><br><span class="line">        int maxA= 10,maxB=20;</span><br><span class="line">        int max = Math.max(maxA, maxB);</span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //比较两个数的最小值</span><br><span class="line">        int minA=50,minB=60;</span><br><span class="line">        int min = Math.min(minA, minB);</span><br><span class="line">        System.out.println(min);</span><br><span class="line"></span><br><span class="line">        //返回两个数的相乘</span><br><span class="line">        int i1 = Math.multiplyExact(x, y);</span><br><span class="line">        System.out.println(i1);</span><br><span class="line"></span><br><span class="line">        //向上取整</span><br><span class="line">        System.out.println(Math.ceil(20.85));//21.0</span><br><span class="line"></span><br><span class="line">        //向下取整</span><br><span class="line">        System.out.println(Math.floor(20.85));//20.0</span><br><span class="line"></span><br><span class="line">        //代表2的三次方，如果第二个参数是0~1之间的小数</span><br><span class="line">        System.out.println(Math.pow(2, 3)); //8.0</span><br><span class="line">        System.out.println(Math.pow(2, 0.5)); //1.4142135623730951</span><br><span class="line"></span><br><span class="line">        //代表开根号</span><br><span class="line">        System.out.println(Math.sqrt(98)); //2.0</span><br><span class="line"></span><br><span class="line">        //开立方根</span><br><span class="line">        System.out.println(Math.cbrt(8));//2.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220918172005955.png" alt="image-20220918172005955" style="zoom:67%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package math;</span><br><span class="line"></span><br><span class="line">public class SystemTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //0:表示当前虚拟机是正常停止</span><br><span class="line">        //非0，表示当前虚拟机异常停止</span><br><span class="line">//        System.exit(0);</span><br><span class="line"></span><br><span class="line">        long l = System.currentTimeMillis();</span><br><span class="line">        System.out.println(l);</span><br><span class="line"></span><br><span class="line">        //拷贝数组</span><br><span class="line">        int[] arr1 = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">        int[] arr2 = new int[10];</span><br><span class="line">        //第一个参数：数据源，要拷贝的数据</span><br><span class="line">        //第二个参数：从数据源哪个索引开始拷贝</span><br><span class="line">        //第三个参数：新数组</span><br><span class="line">        //第四个参数：拷贝到新数组的哪个位置</span><br><span class="line">        //第五个参数：拷贝多少个数据</span><br><span class="line">//        System.arraycopy(arr1,3,arr2,0,7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //课堂练习 arr2 : 0 0 0 0 1 2 3 0 0 0</span><br><span class="line">        System.arraycopy(arr1,0,arr2,4,3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            System.out.print(arr2[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><ul>
<li><p>Runtime表示当前虚拟机的运行环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package math;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class RuntimeTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        System.out.println(runtime);</span><br><span class="line">        int i = runtime.availableProcessors();    //获取CPU的线程数</span><br><span class="line">        System.out.println(i);//12</span><br><span class="line">        long l = runtime.maxMemory();   //JVM能从系统中获取总内存大小(单位byte)</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        long l1 = runtime.totalMemory();   //JVM已经从系统中获取总内存大小(单位byte)</span><br><span class="line">        System.out.println(l1);</span><br><span class="line"></span><br><span class="line">        long l2 = runtime.freeMemory();   //获取jvm剩余多少内存可以使用</span><br><span class="line">        System.out.println(l2);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">           runtime.exec(&quot;notepad&quot;); //运行cmd命令 notepad打开记事本</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul>
<li><p>Object是java中定级父类。所有类都直接或间接的继承于Object类</p>
</li>
<li><p>Object类中的方法可以被所有子类访问。</p>
</li>
<li><p>Object方法</p>
<ul>
<li>toString</li>
<li>equals</li>
<li>clone()&#96; 对象克隆<ul>
<li>方法在底层会帮我们创建一个对象，并把原对象中的数据拷贝过去</li>
<li>重写Object中的clone方法</li>
<li>让JavaBean类实现Cloneable接口</li>
<li>创建元对象并调用clone就可以了</li>
<li>浅克隆</li>
<li>深克隆<ul>
<li>以下的代码深克隆还是有弊端，因为以后是个二维数组又要修改，所以会使用第三方写的代码Gson</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package math;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Student implements Cloneable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int  age;</span><br><span class="line"></span><br><span class="line">    private int[] arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] getArr() &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setArr(int[] arr) &#123;</span><br><span class="line">        this.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age, int[] arr) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写object中的toString</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, arr=&quot; + Arrays.toString(arr) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    //重写object中的equals</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        return age == student.age &amp;&amp; Objects.equals(name, student.name) &amp;&amp; Arrays.equals(arr, student.arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写object中的clone</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        //如果想深克隆,不加这个就是浅克隆。浅克隆如果是引用类型那么复制的是地址值，如果成员属性中有数组，那么复制的是地址值，</span><br><span class="line">        // 如果其中一个修改数组中的元素就会跟着修改，所以定义深克隆</span><br><span class="line"></span><br><span class="line">        int[] data = this.arr;</span><br><span class="line">        //创建新数组，将旧数组里面的数据直接拷贝的新数组里面</span><br><span class="line">        int[]  newData = new int[data.length];</span><br><span class="line">        for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            newData[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">       //直接调用父类中的方法克隆对象</span><br><span class="line">        Student s = (Student) super.clone();</span><br><span class="line">        s.arr = newData;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 浅克隆</span><br><span class="line">     */</span><br><span class="line">//    @Override</span><br><span class="line">//    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">//        return super.clone();</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package math;</span><br><span class="line"></span><br><span class="line">public class ObjectTest &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        int[] data= &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">        Student s = new Student(&quot;蔡&quot;,20,data);</span><br><span class="line">        System.out.println(s);   //Student&#123;name=&#x27;蔡&#x27;, age=20, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;  在javaBean中重写toString就可以这样显示</span><br><span class="line">        System.out.println(s);    //math.Student@1b6d3586    如果没有重写toString方法就会打印出地址值，会使用Object的toString</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Student s1 = new Student();</span><br><span class="line">        Student s2 = new Student();</span><br><span class="line">        boolean result = s1.equals(s2);</span><br><span class="line">        System.out.println(result);   //false  如果在javaBean中不重写equals方法就会比较两个对象的地址值两个地址值是new出来的所以在内存堆中,会使用Object的equals</span><br><span class="line"></span><br><span class="line">        System.out.println(result);   //true  如果在javaBean中重写equals方法就会使用javaBean中重写的equals方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //直接调用javabean类中重写的克隆方法</span><br><span class="line">        Student s4 = (Student) s.clone();</span><br><span class="line">        //修改拷贝后数组的第一个元素的数据</span><br><span class="line">        int[] arr = s4.getArr();</span><br><span class="line">        arr[0] = 55;</span><br><span class="line">        System.out.println(s4);  //Student&#123;name=&#x27;蔡&#x27;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</span><br><span class="line">        System.out.println(s);  //原数组的数组第一个数据也被修改了Student&#123;name=&#x27;蔡&#x27;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //在javabean中重写了浅克隆，变成了深克隆</span><br><span class="line">        System.out.println(s4);  //Student&#123;name=&#x27;蔡&#x27;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</span><br><span class="line">        System.out.println(s);   //Student&#123;name=&#x27;蔡&#x27;, age=20, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><ul>
<li><p>BigInteger构造方法</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220919214226833.png" alt="image-20220919214226833"></p>
</li>
</ul>
<h4 id="BigDecima"><a href="#BigDecima" class="headerlink" title="BigDecima"></a>BigDecima</h4><ul>
<li><p>用于小数的精确计算</p>
</li>
<li><p>用来表示很大的小数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package math;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line">public class BigDecimalTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //使用double形参构造函数会数据不精确</span><br><span class="line">        BigDecimal b = new BigDecimal(0.01);</span><br><span class="line">        BigDecimal bg = new BigDecimal(0.09);</span><br><span class="line">        BigDecimal bg1 = b.add(bg);</span><br><span class="line">        System.out.println(b);  //0.01000000000000000020816681711721685132943093776702880859375</span><br><span class="line">        System.out.println(bg);//0.0899999999999999966693309261245303787291049957275390625</span><br><span class="line">        System.out.println(bg1);//0.09999999999999999687749774324174723005853593349456787109375</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //使用String形参构造函数数据精确</span><br><span class="line">        BigDecimal b1 = new BigDecimal(&quot;0.01&quot;);</span><br><span class="line">        BigDecimal b2 = new BigDecimal(&quot;0.09&quot;);</span><br><span class="line">        //add b1加上b2</span><br><span class="line">        BigDecimal b3 = b1.add(b2);</span><br><span class="line">        System.out.println(b1);  //0.01</span><br><span class="line">        System.out.println(b2);//0.09</span><br><span class="line">        System.out.println(b3);//0.10</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul>
<li><p>作用</p>
<ul>
<li><p>检验字符串是否满足规则</p>
</li>
<li><p>在一段文本中查找满足要求的内容</p>
</li>
<li><p>正则表达式字符的基本操作</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220923130744244.png" alt="image-20220923130744244"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package Day.Api.zhengze;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //判断一个是不是qq号</span><br><span class="line">        String qq = &quot;1311871826&quot;;</span><br><span class="line">        //[1-9]这个代表上面第一个数字不能以0开头  \\d代表数字 &#123;4,9&#125;这个代表除了第一个数字后面的数必须是4~9位数字要不然就是返回false</span><br><span class="line">        System.out.println(qq.matches(&quot;[1-9]\\d&#123;4,9&#125;&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[abc]&quot;));  //true</span><br><span class="line">        System.out.println(&quot;z&quot;.matches(&quot;[abc]&quot;));  //false</span><br><span class="line">        System.out.println(&quot;ab&quot;.matches(&quot;[abc]&quot;)); //false  因为这样[abc]只能匹配字符串一个字符所以false所以要改成[abc][abc]这个就是true</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //[^abc]  ^取反的意思</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[^abc]&quot;));  //false</span><br><span class="line">        System.out.println(&quot;z&quot;.matches(&quot;[^abc]&quot;));  //true</span><br><span class="line">        System.out.println(&quot;zz&quot;.matches(&quot;[^abc]&quot;));  //false</span><br><span class="line">        System.out.println(&quot;zz&quot;.matches(&quot;[^abc][^abc]&quot;));//true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        //[a-zA-Z]可以是a-z的大写和小写</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[a-zA-Z]&quot;)); //true</span><br><span class="line">        System.out.println(&quot;Z&quot;.matches(&quot;[a-zA-Z]&quot;)); //true</span><br><span class="line">        System.out.println(&quot;aa&quot;.matches(&quot;[a-zA-Z]&quot;));//false    //[a-zA-Z][a-zA-Z] true</span><br><span class="line">        System.out.println(&quot;zz&quot;.matches(&quot;[a-zA-Z]&quot;));//false</span><br><span class="line">        System.out.println(&quot;0&quot;.matches(&quot;[a-zA-Z]&quot;));//false    //[a-zA-Z0-9] false  //[0-9] true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------------&quot;);</span><br><span class="line">        //[a-d[m-p]] a到d，或m到p</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true</span><br><span class="line">        System.out.println(&quot;d&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true</span><br><span class="line">        System.out.println(&quot;m&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true</span><br><span class="line">        System.out.println(&quot;p&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true</span><br><span class="line">        System.out.println(&quot;e&quot;.matches(&quot;[a-d[m-p]]&quot;)); //false   //e不在范围内所以是false</span><br><span class="line">        System.out.println(&quot;0&quot;.matches(&quot;[a-d[m-p]]&quot;)); //false  //0是数字正则匹配里面没有数字</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------------&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //[a-z&amp;&amp;[def]]</span><br><span class="line">        //其实就是它们的交集  def</span><br><span class="line">        System.out.println(&quot;d&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //true</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //false</span><br><span class="line">        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //[a-z&amp;&amp;[^bc]]  除了bc字母都可以</span><br><span class="line">        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //true</span><br><span class="line">        System.out.println(&quot;b&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //false</span><br><span class="line">        System.out.println(&quot;z&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //true</span><br><span class="line">        System.out.println(&quot;z&quot;.matches(&quot;[a-z&amp;[^bc]]&quot;));  //true 因为&amp;只能当当是符号不是&amp;&amp;这个才是且</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        //[a-z&amp;&amp;[^m-p]]  除了m-p中的字母，其它字母都可以</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //true</span><br><span class="line">        System.out.println(&quot;m&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //false</span><br><span class="line">        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="jDK7前时间类"><a href="#jDK7前时间类" class="headerlink" title="jDK7前时间类"></a>jDK7前时间类</h4><p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924144225531.png" alt="image-20220924144225531"></p>
<ul>
<li><p>Date  时间</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924150106666.png" alt="image-20220924150106666"></p>
</li>
<li><p>SimpleDateFormat 格式化时间</p>
<ul>
<li>作用<ul>
<li>格式化：把时间变成自己的格式</li>
<li>解析：把字符串表示的时间变成Date</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package Day.Api.date;</span><br><span class="line"></span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class DateTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ParseException &#123;</span><br><span class="line">    </span><br><span class="line">        //时间原点</span><br><span class="line">        Date date1 = new Date(0L);</span><br><span class="line">        System.out.println(date1); //Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">    </span><br><span class="line">        Date date = new Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        //格式化时间YYYY年MM月dd日 HH:mm:ss E</span><br><span class="line">        SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss E&quot;);</span><br><span class="line">        String format = s.format(date);</span><br><span class="line">        System.out.println(format);  //2022年09月24日 15:23:32 星期六</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //解析时间</span><br><span class="line">        String d = &quot;2022-09-24 15-26-20&quot;;</span><br><span class="line">        SimpleDateFormat sp = new SimpleDateFormat(&quot;yyyy-MM-dd HH-mm-ss&quot;);</span><br><span class="line">        Date parse = sp.parse(d);</span><br><span class="line">        System.out.println(parse); //Sat Sep 24 15:26:20 CST 2022</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Calendar 日历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package Day.Api.date;</span><br><span class="line"></span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class DateTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ParseException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       //Calendar 是一个抽象类，不能直接new</span><br><span class="line"></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        int year = c.get(Calendar.YEAR);</span><br><span class="line">        int moth = c.get(Calendar.MONTH) + 1;</span><br><span class="line">        int dt = c.get(Calendar.DATE);</span><br><span class="line">        int week = c.get(Calendar.DAY_OF_WEEK);  // 1(星期日) 2(星期一) 3(星期二) 4(星期三) 5(星期四) 6(星期五) 7(星期六)</span><br><span class="line">        System.out.println(year+&quot;年&quot;+moth+&quot;月&quot;+dt+&quot;日&quot;+&quot; &quot;+week(week)); //2022年9月24日</span><br><span class="line"></span><br><span class="line">        //修改年为2023年</span><br><span class="line">        c.set(Calendar.YEAR,2023);</span><br><span class="line">        System.out.println(c.get(Calendar.YEAR));</span><br><span class="line">        //如果想修改月份为12月，那么修改值要填11，因为Calendar的月份是少1的</span><br><span class="line">        c.set(Calendar.MONTH,11);</span><br><span class="line">        System.out.println(c.get(Calendar.MONTH));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //定义一个方法传入外国人对星期几的数字转换成中文</span><br><span class="line">    public static String week(int week)&#123;</span><br><span class="line">        String[] wek = &#123;&quot;&quot;,&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;&#125;;</span><br><span class="line">        return wek[week];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="jdk8时间类"><a href="#jdk8时间类" class="headerlink" title="jdk8时间类"></a>jdk8时间类</h4><ul>
<li>为什么要学jdk8新增时间相关类<ul>
<li>代码层面<ul>
<li>jdk：代码麻烦 </li>
<li>jdk8：简单<ul>
<li>判断的方法</li>
<li>计算时间间隔的方法</li>
</ul>
</li>
</ul>
</li>
<li>安全层面<ul>
<li>jdk：多线程环境下会导致数据安全的问题</li>
<li>jdk8：时间日期对象都是不可变的，解决了这个问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220924165212609.png" alt="image-20220924165212609"></p>
<ul>
<li><p>时区，时间戳，带时区的时间，格式化和解析时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package Day.Api.date;</span><br><span class="line"></span><br><span class="line">import java.time.Instant;</span><br><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.time.ZonedDateTime;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * creator: 蔡芳灿</span><br><span class="line"> * Date: 2022/9/24</span><br><span class="line"> * Time: 16:37</span><br><span class="line"> * 需求：</span><br><span class="line"> */</span><br><span class="line">public class DateTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //ZoneId</span><br><span class="line">        //获取java中所有支持时区</span><br><span class="line">        Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">        System.out.println(availableZoneIds);</span><br><span class="line"></span><br><span class="line">        //获取电脑时区</span><br><span class="line">        ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">        System.out.println(zoneId); //Asia/Shanghai</span><br><span class="line">        //设置指定的时区</span><br><span class="line">        ZoneId of = ZoneId.of(&quot;Asia/Aden&quot;);</span><br><span class="line">        System.out.println(of);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------Instant--------------&quot;);</span><br><span class="line"></span><br><span class="line">        //获取的世界标准时间对象，如果想获取当前时间小时需要加8个小时</span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 根据（秒/毫秒/纳秒）获取Instant对象</span><br><span class="line">         */</span><br><span class="line">        //根据纳秒获取</span><br><span class="line">        Instant instant1 = Instant.ofEpochMilli(0L);</span><br><span class="line">        System.out.println(instant1);//1970-01-01T00:00:00Z</span><br><span class="line"></span><br><span class="line">        //根据秒</span><br><span class="line">        Instant instant2 = Instant.ofEpochSecond(1);</span><br><span class="line">        System.out.println(instant2);//1970-01-01T00:00:01Z 根据时间原点加一秒</span><br><span class="line"></span><br><span class="line">        //第一个参数根据秒 ，第二个参数根据纳秒</span><br><span class="line">        Instant instant3 = Instant.ofEpochSecond(1L, 1000000000L);</span><br><span class="line">        System.out.println(instant3);//1970-01-01T00:00:02Z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //指定地区的时间点</span><br><span class="line">        ZonedDateTime zonedDateTime = now.atZone(ZoneId.of(&quot;Asia/Shanghai&quot;));</span><br><span class="line">        System.out.println(zonedDateTime);//2022-09-25T18:40:57.110030600+08:00[Asia/Shanghai]</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------ZonedDateTime-----------&quot;);</span><br><span class="line"></span><br><span class="line">        //获取当前时区时间的对象</span><br><span class="line">        ZonedDateTime now1 = ZonedDateTime.now();</span><br><span class="line">        System.out.println(now1);//2022-09-25T18:46:16.151643500+08:00[Asia/Shanghai]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------DateTimeFormatter---------------&quot;);</span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span><br><span class="line">        String format = dateTimeFormatter.format(now1);</span><br><span class="line">        System.out.println(format);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><ul>
<li>什么是包装类<ul>
<li>基本数据类型对应的对象</li>
</ul>
</li>
<li>JDK5新增的特性<ul>
<li>自动装箱</li>
<li>自动拆箱</li>
</ul>
</li>
<li>各个基本类型的包装类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20220929215914294.png" alt="image-20220929215914294"></p>
<p>​						</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package Day.packaging;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * creator: 蔡芳灿</span><br><span class="line"> * Date: 2022/9/29</span><br><span class="line"> * Time: 21:56</span><br><span class="line"> * 需求：</span><br><span class="line"> */</span><br><span class="line">public class TestInteger &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //包装类，数字引用数字类型 Jdk5写法</span><br><span class="line">        //利用构造方法来创建对象</span><br><span class="line">        System.out.println(&quot;----------构造法创建对象---------------&quot;);</span><br><span class="line">        Integer a = new Integer(10);</span><br><span class="line">        Integer a1 = new Integer(&quot;10&quot;);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(a1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------静态方法创建对象------------------&quot;);</span><br><span class="line"></span><br><span class="line">        //利用静态方法创建对象</span><br><span class="line">        Integer in = Integer.valueOf(10);</span><br><span class="line">        Integer integer = Integer.valueOf(&quot;123&quot;);</span><br><span class="line">        Integer integer1 = Integer.valueOf(&quot;123&quot;, 8);</span><br><span class="line">        System.out.println(in);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">        System.out.println(&quot;输出8进制的数:&quot;+integer1);</span><br><span class="line"></span><br><span class="line">        Integer c=10;</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //两个创建的对象区别</span><br><span class="line">        //这个判断的是数字如果数字不在-128~127那么源码中会new出来的所以超过127就是判断地址值</span><br><span class="line">        Integer i5 = Integer.valueOf(127);</span><br><span class="line">        Integer i6 = Integer.valueOf(127);</span><br><span class="line">        System.out.println(i5==i6);  //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Integer i7 = Integer.valueOf(128);</span><br><span class="line">        Integer i8 = Integer.valueOf(128);</span><br><span class="line">        System.out.println(i7==i8);  //false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //底下这种判断的是地址值所以是false</span><br><span class="line">        Integer i1 = new Integer(127);</span><br><span class="line">        Integer i2 = new Integer(127);</span><br><span class="line">        System.out.println(i1==i2);//false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Integer i3 = new Integer(128);</span><br><span class="line">        Integer i4 = new Integer(128);</span><br><span class="line">        System.out.println(i3==i4);//false</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><ul>
<li><p>查找算法</p>
<ul>
<li><p>基本查找    </p>
<ul>
<li><p>基本查找的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package find;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * creator: 蔡芳灿</span><br><span class="line"> * Date: 2022/9/30</span><br><span class="line"> * Time: 12:52</span><br><span class="line"> * 需求：查找算法</span><br><span class="line"> */</span><br><span class="line">public class BasicSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr = &#123;20,30,40,60,70,90,100,120,150&#125;;</span><br><span class="line"></span><br><span class="line">        //基本查找</span><br><span class="line">        boolean b = basicSearch(arr, 20);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //基本查找</span><br><span class="line">    public static boolean basicSearch(int Array[],int number)&#123;</span><br><span class="line">        for (int i = 0; i &lt; Array.length; i++) &#123;</span><br><span class="line">            if (Array[i]==number)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>二分查找&#x2F;折半查找</p>
<ul>
<li><p>二分查找前提条件是数组的数据是顺序的</p>
</li>
<li><p>提高查找效率</p>
</li>
<li><p>二分查找过程</p>
<ul>
<li>min和max表示当前要查找的范围</li>
<li>中间是在min和max中间的</li>
<li>如果要查找的元素在mid的左边，缩小范围时，min不变， max等于mid减1</li>
<li>如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1</li>
</ul>
</li>
<li><p>二分查找的代码实现</p>
<ul>
<li><p>&#96;&#96;&#96;<br>package find;</p>
<p>&#x2F;**</p>
<ul>
<li><p>Created with IntelliJ IDEA.</p>
</li>
<li><p>creator: 蔡芳灿</p>
</li>
<li><p>Date: 2022&#x2F;9&#x2F;30</p>
</li>
<li><p>Time: 12:52</p>
</li>
<li><p>需求：查找算法<br> *&#x2F;<br>public class BasicSearch {<br> public static void main(String[] args) {</p>
<pre><code> int[] arr = &#123;20,30,40,60,70,90,100,120,150&#125;;


 int i = ErBasicSearch(arr, 30);
 System.out.println(i);
</code></pre>
<p> }</p>
<p> &#x2F;&#x2F;二分查找</p>
<p> &#x2F;**</p>
<ul>
<li></li>
<li>@param Array</li>
<li>@param number</li>
<li>@return</li>
<li>1, min和max表示当前要查找的范围</li>
<li>2，中间是在min和max中间的</li>
<li>3,如果要查找的元素在mid的左边，缩小范围时，min不变， max等于mid减1</li>
<li>4,如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1<br>  *&#x2F;<br> public static int ErBasicSearch(int Array[],int number){<br> int max &#x3D;   Array.length-1;<br> int min &#x3D; 0;<br> while (true){<br> int mid &#x3D; (max+min)&#x2F;2;<br> if (min&gt;max){<br>     return -1;<br> }<br> if (Array[mid]&gt;number){<br>     max&#x3D;mid-1;<br><br> }else if (Array[mid]&lt;number){<br>     min &#x3D; mid+1;<br> }else  {<br>     return mid;<br> }<br> }</li>
</ul>
<p> }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Arrays</span><br><span class="line"></span><br><span class="line">- 常用方法</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    package Day.Api.Arrays;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    import java.util.Arrays;</span><br><span class="line">    import java.util.Collection;</span><br><span class="line">    import java.util.Comparator;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Created with IntelliJ IDEA.</span><br><span class="line">     * creator: 蔡芳灿</span><br><span class="line">     * Date: 2022/10/2</span><br><span class="line">     * Time: 16:42</span><br><span class="line">     * 需求：</span><br><span class="line">     */</span><br><span class="line">    public class MyArrayTest01 &#123;</span><br><span class="line">    </span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">            System.out.println(&quot;--------Arrays toString----------------&quot;);</span><br><span class="line">            //返回指定数组内容的字符串表示形式</span><br><span class="line">            System.out.println(Arrays.toString(arr));  //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">            //使用二分查找查找元素</span><br><span class="line">            //第一:二分查找的数组中的元素是有序的，而且是升序的</span><br><span class="line">            //第二：如果查找的数据存在返回索引</span><br><span class="line">            System.out.println(&quot;--------Arrays binarySearch----------------&quot;);</span><br><span class="line">            System.out.println(Arrays.binarySearch(arr, 5));//4</span><br><span class="line">            System.out.println(Arrays.binarySearch(arr, 10));//9</span><br><span class="line">            System.out.println(Arrays.binarySearch(arr, 20));//-11</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">            //复制新数组</span><br><span class="line">            //第一个参数是旧数组的数据</span><br><span class="line">            //第二个参数是，要从数组中的复制多少个数据到新数组，如果新数组的长度大于旧数组的长度，那么后面的数据用数组的初始值</span><br><span class="line">            System.out.println(&quot;--------Arrays copyOf----------------&quot;);</span><br><span class="line">            int[] ints = Arrays.copyOf(arr, 20);</span><br><span class="line">            System.out.println(Arrays.toString(ints));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">            //排序</span><br><span class="line">            System.out.println(&quot;--------Arrays sort  升序----------------&quot;);</span><br><span class="line">            Integer[] array = &#123;20, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;;</span><br><span class="line">    </span><br><span class="line">    //        Arrays.sort(array);</span><br><span class="line">    //        System.out.println(Arrays.toString(array));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">            //降序排序o2-o1</span><br><span class="line">            //升序排序o1-o2</span><br><span class="line">            Arrays.sort(array,new Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">    </span><br><span class="line">                @Override</span><br><span class="line">                public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">    </span><br><span class="line">                    return o2-o1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="lambda-JDK8"><a href="#lambda-JDK8" class="headerlink" title="lambda  JDK8"></a>lambda  JDK8</h4><ul>
<li>注意事项<ul>
<li>Lambda表达式可以用来简化匿名内部类的书写</li>
<li>Lambda表达式只能简化函数式接口的匿名内部类的写法</li>
<li>函数式接口：<ul>
<li>有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package Day.Api.Arrays;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * creator: 蔡芳灿</span><br><span class="line"> * Date: 2022/10/2</span><br><span class="line"> * Time: 17:22</span><br><span class="line"> * 需求：</span><br><span class="line"> */</span><br><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Integer[] array = &#123;20, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;;</span><br><span class="line">        //降序排序</span><br><span class="line">        // lambda表达式 -&gt;</span><br><span class="line">//        Arrays.sort(array, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line">//                    return o2 - o1;</span><br><span class="line">//                &#125;</span><br><span class="line">//        );</span><br><span class="line">        //Integer如果数据类型相同们可以省略</span><br><span class="line">//        Arrays.sort(array, (o1,  o2) -&gt; &#123;</span><br><span class="line">//                    return o2 - o1;</span><br><span class="line">//                &#125;</span><br><span class="line">//        );</span><br><span class="line">        //也可以省略花括号和return</span><br><span class="line">        Arrays.sort(array, (o1,  o2) -&gt;o2 - o1);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h4><ul>
<li><p>Collection：是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的</p>
<ul>
<li>遍历方式<ul>
<li>迭代器遍历</li>
<li>增强for遍历</li>
<li>Lambda表达式遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>List</p>
<ul>
<li>添加的元素是有序的、可重复、有索引</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li>添加的元素是无序、不重复、五索引</li>
</ul>
</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li>迭代器遍历<ul>
<li>迭代器在java中类是Iterator，迭代器是集合专用的遍历方式。</li>
</ul>
</li>
<li>Collection集合获取迭代器</li>
<li>注意事项<ul>
<li>报错NoSuchElementException</li>
<li>迭代器遍历完毕，指针不会复位</li>
<li>迭代器遍历时，不能用集合的方法进行增强或者删除</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package Day;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * creator: 蔡芳灿</span><br><span class="line"> * Date: 2022/10/3</span><br><span class="line"> * Time: 16:56</span><br><span class="line"> * 需求：迭代器遍历</span><br><span class="line"> */</span><br><span class="line">public class Day186 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;aaa&quot;);</span><br><span class="line">        list.add(&quot;bbb&quot;);</span><br><span class="line">        list.add(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"></span><br><span class="line">        //查看集合指针位置是否有元素，如果有数就是true，没有就是false</span><br><span class="line">        while (it.hasNext())&#123;</span><br><span class="line">            //使用next方法获取第一个元素，并且移动指针到集合的第二个位置</span><br><span class="line">            String str = it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003172048287.png" alt="image-20221003172048287"></p>
<h4 id="集合遍历方式"><a href="#集合遍历方式" class="headerlink" title="集合遍历方式"></a>集合遍历方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package Day;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ListIterator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * creator: 蔡芳灿</span><br><span class="line"> * Date: 2022/10/3</span><br><span class="line"> * Time: 18:49</span><br><span class="line"> * 需求：List 五种遍历</span><br><span class="line"> */</span><br><span class="line">public class Day188 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list  = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(&quot;aaa&quot;);</span><br><span class="line">        list.add(&quot;bbb&quot;);</span><br><span class="line">        list.add(1,&quot;ccc&quot;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        //迭代器遍历  如果想删除元素请用迭代器遍历</span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        while (it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            if (&quot;bbb&quot;.equals(str))&#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        //列表迭代器遍历  如果想添加元素请用列表迭代器遍历</span><br><span class="line">        ListIterator&lt;String&gt; itList = list.listIterator();</span><br><span class="line">        while (itList.hasNext())&#123;</span><br><span class="line">            String str = itList.next();</span><br><span class="line">            if (&quot;aaa&quot;.equals(str))&#123;</span><br><span class="line">                itList.add(&quot;bbb&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        //如果单纯遍历数据请用增强for或Lambda表达式遍历</span><br><span class="line">        for (String s : list) &#123;</span><br><span class="line">            System.out.print(s+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        list.forEach(s -&gt; System.out.print(s+&quot; &quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        //如果想操作索引，使用普通for</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.print(list.get(i)+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>什么是数据结构</p>
<ul>
<li>计算机存储、组织数据的方式</li>
<li>是指数据相互之间是以什么方式排列在一起的</li>
<li>数据结构是为了更加方便的管理和使用数据，需要结合具体的业务场景来进行选择</li>
<li>一般情况下，精心选择数据结构可以带来跟高的运行或者存储效率</li>
</ul>
</li>
<li><p>常见的数据结构</p>
<ul>
<li><p>栈</p>
<ul>
<li><p>栈的特点：后进先出，先进后出</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003191448309.png" alt="image-20221003191448309"></p>
</li>
</ul>
</li>
<li><p>队列</p>
<ul>
<li><p>特点：先进先出，后进后出</p>
<p><img src="https://raw.githubusercontent.com/csh1311/blogImage/main/image-20221003191404657.png" alt="image-20221003191404657"></p>
</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li>特点：内存连续区域，查询快，增删慢</li>
</ul>
</li>
<li><p>链表</p>
<ul>
<li>特点：元素是游离的，查询慢，首尾操作极快</li>
</ul>
</li>
<li><p>二叉树</p>
<ul>
<li>二叉查找树遍历方式</li>
<li>前序遍历：当前节点，左子节点，右子节点<ul>
<li>中序遍历：左子节点，中子节点，右子节点</li>
<li>后序遍历：左子节点，右子节点，当前节点</li>
<li>层序遍历：一层一层的去遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉查找树平衡二叉树</p>
</li>
<li><p>红黑树</p>
<ul>
<li>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构</li>
<li>1972年出现，当时被称为平衡二叉B树。后来，1978年被修改为如今的“红黑叔”</li>
<li>它是一种特殊的二叉树查找树，红黑树的每一个节点上都有存储位表示节点的颜色</li>
<li>每一个节点可以是红或者黑，红黑树不是高度平衡的，它的平衡是通过“红黑规则”进行实现的</li>
<li>红黑树规则<ul>
<li>每一个节点或是红色的，或是黑色的</li>
<li>根节点必须是黑色的</li>
<li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点（Nil）是黑色的</li>
<li>如果某一个节点是红色，那么它的节点必须是黑色（不能出现两个红色节点相连的情况）</li>
<li>对每一个节点，从节点到其所有后代叶节点的简单路劲上，均包含相同的黑色节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ArrayList底层原理"><a href="#ArrayList底层原理" class="headerlink" title="ArrayList底层原理"></a>ArrayList底层原理</h4><ul>
<li>利用空参创建的集合，在底层创建一个默认长度为0的数组</li>
<li>添加一个元素时，底层会创建一个新的长度为10的数组</li>
<li>存满时，会扩容1.5倍</li>
<li>如果一次添加多个元素，1.5倍还放不下，则新床数组的长度以实际为准</li>
</ul>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ul>
<li><p>什么是泛型</p>
<ul>
<li>JDK5引入的特性，可以在编译阶段约束操作的数据类类型，并进行检查</li>
</ul>
</li>
<li><p>泛型好处</p>
<ul>
<li>统一数据类型</li>
<li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来</li>
</ul>
</li>
<li><p>泛型的细节</p>
<ul>
<li>泛型中不能写基本数据类型</li>
<li>指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型</li>
<li>如果不写泛型，类型默认是Object</li>
</ul>
</li>
<li><p>哪里可以定义泛型</p>
<ul>
<li>泛型类：在类名后定义泛型，创建该类对象的时候，确定类型</li>
<li>泛型方法：在修饰符后面定义泛型，调用方法的时候确定类型</li>
<li>泛型接口：在接口名后面定义泛型，实现类确定类型，实现类延续泛型</li>
</ul>
</li>
<li><p>泛型的继承和通配符</p>
<ul>
<li>泛型不具备继承性，但是数据具备继承性</li>
</ul>
</li>
</ul>
<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><ul>
<li>无序：存取顺序不一致</li>
<li>不重复：可以去除重复</li>
<li>无索引：没有带索引的方法，所以不能使用普通for遍历，也不能通过索引来获取元素</li>
<li>set集合实现类<ul>
<li>HashSet：无序、不重复、无索引</li>
<li>LinkedHashSet：有序、不重复、无索引</li>
<li>TreeSet：可排序、不重复、五索引 <ul>
<li>TreeSet自定义排序规则有几种方式<ul>
<li>方法一：javabean类实现Comparable接口，指定比较规则</li>
<li>方法二：创建集合时，自定义Comparator比较对象，指定比较规则</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h4><ul>
<li><p>特点</p>
<ul>
<li>双列集合一次需要存一对数据，分别为键和值</li>
<li>键不能重复，值可以重复</li>
<li>键和值是一一对应的，每一个键只能找到自己对应的值<ul>
<li>键+值这个整体我们称之为“键值对”或者“键值对对象”在java中叫做“Entry对象”</li>
</ul>
</li>
</ul>
<p>						</p>
</li>
<li><p>HashMap</p>
<ul>
<li><p>特点</p>
<ul>
<li>HashMap里面的一个实现类</li>
<li>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了</li>
<li>特点都是由键决定的：无序、不重复、无索引</li>
<li>HashMap跟HashSet底层原理一模一样的，都是哈希表结构</li>
</ul>
</li>
<li><p>HashMap基本方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package Day.Api.map;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * creator: 蔡芳灿</span><br><span class="line"> * Date: 2022/10/5</span><br><span class="line"> * Time: 21:17</span><br><span class="line"> * 需求：</span><br><span class="line"> */</span><br><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String,String&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        //添加元素</span><br><span class="line">        //put方法的细节</span><br><span class="line">        //添加/覆盖</span><br><span class="line">        //在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中</span><br><span class="line">        //在添加数据时候，如果键存在，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回</span><br><span class="line">        map.put(&quot;cai&quot;,&quot;ss&quot;);</span><br><span class="line">        map.put(&quot;ss&quot;,&quot;cai&quot;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //删除</span><br><span class="line">        map.remove(&quot;ss&quot;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        //判断集合中的键是否存在</span><br><span class="line">        System.out.println(map.containsKey(&quot;cai&quot;));</span><br><span class="line">        System.out.println(map.containsValue(&quot;ss&quot;));</span><br><span class="line"></span><br><span class="line">        //判断集合的长度</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //清空集合</span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        //判读集合是否为空</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap遍历方式</p>
<ul>
<li><pre><code>package Day.Api.map;

import java.util.*;
import java.util.function.BiConsumer;

/**
 * Created with IntelliJ IDEA.
 * creator: 蔡芳灿
 * Date: 2022/10/5
 * Time: 21:34
 * 需求：
 */
public class MapTestFor &#123;
    public static void main(String[] args) &#123;

        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;xiao&quot;,&quot;di&quot;);
        map.put(&quot;dd&quot;,&quot;cc&quot;);
        map.put(&quot;ll&quot;,&quot;jj&quot;);
        map.put(&quot;aa&quot;,&quot;bb&quot;);
        System.out.println(map);


        //


        //遍历键找值
        Set&lt;String&gt; m = map.keySet();
        for (String key : m) &#123;
//            System.out.println(key);
            String value = map.get(key);
//            System.out.println(key+&quot;=&quot;+value);
        &#125;



        //迭代器遍历
        Iterator&lt;String&gt; it = m.iterator();
        while (it.hasNext())&#123;
            String str = it.next();
            String s = map.get(str);
//            System.out.println(s);
        &#125;

        //Lambda表达式遍历
        m.forEach(s -&gt; System.out.println(s));


        System.out.println(&quot;-------------键值对遍历-----------------&quot;);

        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();
        for (Map.Entry&lt;String, String&gt; stringStringEntry : entrySet) &#123;
            System.out.println(stringStringEntry.getKey()+&quot;=&quot;+stringStringEntry.getValue());
        &#125;


        System.out.println(&quot;----------------Lambda遍历-------------&quot;);
        map.forEach(( key, value) -&gt; System.out.println(key+&quot;=&quot;+value));

    &#125;

&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>HashMap总结</p>
<ul>
<li>HashMap底层是哈希表结构</li>
<li>依赖于hashCode方法和equals方法保证键的唯一</li>
<li>如果键存储的是自定义对象，需要重写hashCode和equals方法</li>
<li>如果值存储自定义对象，不需要重写hashCode和equals方法</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
    </div>
   
    
    
    

</div>

    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

<aside id="article-toc" role="navigation" class="fixed">
<div id="article-toc-inner" style="overflow-y: auto;scrollbar-width: none;">
    <strong class="sidebar-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%82%B9"><span class="toc-text">重点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E5%92%8CAPI%E6%96%87%E6%A1%A3"><span class="toc-text">API和API文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-text">重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%EF%BC%8Csuper"><span class="toc-text">this，super()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-text">final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">权限修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math"><span class="toc-text">Math</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System"><span class="toc-text">System</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime"><span class="toc-text">Runtime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object"><span class="toc-text">Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigInteger"><span class="toc-text">BigInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigDecima"><span class="toc-text">BigDecima</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jDK7%E5%89%8D%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-text">jDK7前时间类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk8%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-text">jdk8时间类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">常见算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda-JDK8"><span class="toc-text">lambda  JDK8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">集合体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">集合遍历方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">ArrayList底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-text">set集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-text">双列集合</span></a></li></ol>
</div>
</aside>

<style>
    #article-toc-inner:after,#article-toc-inner:before,.inner:before{
        content: "";
        display: table;
    }
    #article-toc-inner:after,.inner:after{
        clear: both;
    }
    @media screen{
        #article-toc-innerm,.inner{
            padding: 0 20px;
        }
    }
#article-toc{
    display: none;
    float: right;
    width: 25%;
    margin-right: -220px;
    opacity: .8;
}
@media screen and (min-width:769px) {
    #article-toc{
        display: block;
    }
}
#article-toc.fixed{
    position: absolute;
    top:0;
    bottom:0;
    right: 220px;
    padding-top: 55px;

}
.fixed #article-toc-inner{
    position: fixed;
    width: 260px;
    top: 0;
    bottom: 0;
    padding-top: 55px;
}
#article-toc-inner ol {
    margin-left: -5px;
}

#article-toc-inner::-webkit-scrollbar {
  display: none; /* Chrome Safari */
}
li{
    list-style-type: none;
}
</style>


</html>