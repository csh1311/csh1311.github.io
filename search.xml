<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql</title>
      <link href="/2023/07/01/mysql/"/>
      <url>/2023/07/01/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="使用RPM安装MySQL-存储库"><a href="#使用RPM安装MySQL-存储库" class="headerlink" title="使用RPM安装MySQL 存储库"></a>使用RPM安装MySQL 存储库</h2><pre><code>rpm -Uvh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</code></pre><h2 id="使用yum命令安装软件包"><a href="#使用yum命令安装软件包" class="headerlink" title="使用yum命令安装软件包"></a>使用yum命令安装软件包</h2><pre><code>yum install mysql-server</code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>​在这里会出现系统已经安装了与MySQL 5.7存储库关联的GPG密钥，但密钥不匹配正在尝试安装的软件包</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230701160233875.png" alt="image-20230701160233875"></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h4 id="解决办法一："><a href="#解决办法一：" class="headerlink" title="解决办法一："></a>解决办法一：</h4><ol><li><p>清除YUM缓存：执行以下命令以清除YUM缓存并尝试重新安装</p><pre><code>yum clean all</code></pre></li><li><p>更新密钥：执行以下命令来更新存储库的GPG密钥：</p><pre><code>rpm --import https://dev.mysql.com/doc/mysql-repo-extractor/KEY</code></pre></li></ol><h4 id="解决办法二"><a href="#解决办法二" class="headerlink" title="解决办法二"></a>解决办法二</h4><ol><li><p>使用以下网站下载GPG密钥</p><pre><code>https://repo.mysql.com/</code></pre><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230701155413611.png" alt="image-20230701155413611"></p></li><li><p>密钥</p><pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----mQINBGG4urcBEACrbsRa7tSSyxSfFkB+KXSbNM9rxYqoB78u107skReefq4/+Y72TpDvlDZLmdv/lK0IpLa3bnvsM9IE1trNLrfi+JES62kaQ6hePPgn2RqxyIirt2seSi3Z3n3jlEg+mSdhAvW+b+hFnqxo+TY0U+RBwDi4oO0YzHefkYPSmNPdlxRPQBMv4GPTNfxERx6XvVSPcL1+jQ4R2cQFBryNhidBFIkoCOszjWhm+WnbURsLheBp757lqEyrpCufz77zlq2gEi+wtPHItfqsx3rzxSRqatztMGYZpNUHNBJkr13npZtGW+kdN/xu980QLZxN+bZ88pNoOuzD6dKcpMJ0LkdUmTx5z9ewiFiFbUDzZ7PECOm2g3veJrwr79CXDLE1+39Hr8rDM2kDhSr9tAlPTnHVDcaYIGgSNIBcYfLmt91133klHQHBIdWCNVtWJjq5YcLQJ9TxG9GQzgABPrm6NDd1t9j7w1L7uwBvMB1wgpirRTPVfnUSCd+025PEF+wTcBhfnzLtFj5xD7mNsmDmeHkF/sDfNOfAzTE1v2wq0ndYU60xbL6/yl/Nipyr7WiQjCG0m3WfkjjVDTfs7/DXUqHFDOu4WMF9v+oqwpJXmAeGhQTWZC/QhWtrjrNJAgwKpp263gDSdW70ekhRzsok1HJwX1SfxHJYCMFs2aH6ppzNsQARAQABtDZNeVNRTCBSZWxlYXNlIEVuZ2luZWVyaW5nIDxteXNxbC1idWlsZEBvc3Mub3JhY2xlLmNvbT6JAlQEEwEIAD4WIQSFm+jXxYb1OEMLGcJGe5QtOnm9KQUCYbi6twIbAwUJA8JnAAULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRBGe5QtOnm9KUewD/992sS31WLGoUQ6NoL7qOB4CErkqXtMzpJAKKg2jtBGG3rKE1/0VAg1D8AwEK4LcCO407wohnH0hNiUbeDck5x20pgS5SplQpuXX1K9vPzHeL/WNTb98S3H2Mzj4o9obED6Ey52tTupttMF8pC9TJ93LxbJlCHIKKwCA1cXud3GycRN72eqSqZfJGdsaeWLmFmHf6oee27d8XLoNjbyAxna/4jdWoTqmp8oT3bgv/TBco23NzqUSVPi+7ljS1hHvcJuoJYqaztGrAEf/lWIGdfl/kLEh8IYx8OBNUojh9mzCDlwbs83CBqoUdlzLNDdwmzu34Aw7xK14RAVinGFCpo/7EWoX6weyB/zqevUIIE89UABTeFoGih/hx2jdQV/NQNthWTW0jH0hmPnajBVAJPYwAuO82rx2pnZCxDATMn0elOkTue3PCmzHBF/GT6c65aQC4aojj0+Veh787QllQ9FrWbwnTz+4fNzU/MBZtyLZ4JnsiWUs9eJ2V1g/A+RiIKu357Qgy1ytLqlgYiWfzHFlYjdtbPYKjDaScnvtY8VO2Rktm7XiV4zKFKiaWp+vuVYpR0/7Adgnlj5Jt9lQQGOr+Z2VYx8SvBcC+by3XAtYkRHtX5u4MLlVS3gcoWfDiWwCpvqdK21EsXjQJxRr3dbSn0HaVj4FJZX0QQ7WZm6WLkCDQRhuLq3ARAA6RYjqfC0YcLGKvHhoBnsX29vy9Wn1y2JYpEnPUIB8X0VOyz5/ALv4Hqtl4THkH+mmMuhtndoq2BkCCk508jWBvKS1S+Bd2esB45BDDmIhuX3ozu9Xza4i1FsPnLkQ0uMZJv30ls2pXFmskhYyzmo6aOmH2536LdtPSlXtywfNV1HEr69V/AHbrEzfoQkJ/qvPzELBOjfjwtDPDePiVgW9LhktzVzn/BjO7XlJxw4PGcxJG6VApsXmM3t2fPN9eIHDUq8ocbHdJ4en8/bJDXZd9ebQoILUuCg46hE3p6nTXfnPwSRnIRnsgCzeAz4rxDR4/Gv1Xpzv5wqpL21XQi3nvZKlcv7J1IRVdphK66De9GpVQVTqC102gqJUErdjGmxmyCA1OOORqEPfKTrXz5YUGsWwpH+4xCuNQP0qmreRw3ghrH8potIr0iOVXFic5vJfBTgtcuEB6E6ulAN+3jqBGTaBML0jxgj3Z5VC5HKVbpg2DbB/wMrLwFHNAbzV5hj2Os5Zmva0ySP1YHB26pAW8dwB38GBaQvfZq3ezM4cRAo/iJ/GsVE98dZEBO+Ml+0KYj+ZG+vyxzo20sweun7ZKT+9qZM90f6cQ3zqX6IfXZHHmQJBNv73mcZWNhDQOHs4wBoq+FGQWNqLU9xaZxdXw80r1viDAwOy13EUtcVbTkAEQEAAYkCPAQYAQgAJhYhBIWb6NfFhvU4QwsZwkZ7lC06eb0pBQJhuLq3AhsMBQkDwmcAAAoJEEZ7lC06eb0pSi8P/iy+dNnxrtiENn9vkkA7AmZ8RsvPXYVeDCDSsL7UfhbS77r2L1qTa2aB3gAZUDIOXln51lSxMeeLtOequLMEV2Xi5km70rdtnja5SmWfc9fyExunXnsOhg6UG872At5CGEZU0c2Nt/hlGtOR3xbt3O/Uwl+dErQPA4BUbW5K1T7OC6oPvtlKfF4bGZFloHgt2yE9YSNWZsTPe6XJSapemHZLPOxJLnhs3VBirWE31QS0bRl5AzlO/fg7ia65vQGMOCOTLpgChTbcZHtozeFqva4IeEgE4xN+6r8WtgSYeGGDRmeMEVjPM9dzQObf+SvGd58u2z9f2agPK1H32c69RLoA0mHRe7Wkv4izeJUc5tumUY0e8OjdenZZjT3hjLh6tM+mrp2oWnQIoed4LxUw1dhMOj0rYXv6laLGJ1FsW5eSke7ohBLcfBBTKnMCBohROHy2E63Wggfsdn3UYzfqZ8cfbXetkXuLS/OM3MXbiNjg+ElYzjgWrkayu7yLakZx+mx6sHPIJYm2hzkniMG29d5mGl7ZT9emP9b+CfqGUxoXJkjs0gnDl44bwGJ0dmIBu3ajVAaHODXyY/zdDMGjskfEYbNXCAY2FRZSE58tgTvPKD++Kd2KGplMU2EIFT7JYfKhHAB5DGMkx92HUMidsTSKHe+QnnnoFmu4gnmDU31i=Xqbo-----END PGP PUBLIC KEY BLOCK-----</code></pre></li><li><p>在centos7路径下 </p><pre><code>cd /etc/pki/rpm-gpg/</code></pre></li><li><p>创建一个文件,将上面的密钥全部粘贴，</p><pre><code>vim RPM-GPG-KEY-mysql</code></pre></li><li><p>重新运行以下命令</p><pre><code>yum install mysql-server</code></pre></li></ol><h2 id="启动和查看mysql"><a href="#启动和查看mysql" class="headerlink" title="启动和查看mysql"></a>启动和查看mysql</h2><pre><code>systemctl start mysqldsystemctl status mysqld</code></pre><h2 id="查看mysql初始密码"><a href="#查看mysql初始密码" class="headerlink" title="查看mysql初始密码"></a>查看mysql初始密码</h2><pre><code>grep &#39;temporary password&#39; /var/log/mysqld.log</code></pre><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230701160617413.png" alt="image-20230701160617413"></p><h2 id="加强MySQL的安全性"><a href="#加强MySQL的安全性" class="headerlink" title="加强MySQL的安全性"></a>加强MySQL的安全性</h2><pre><code>mysql_secure_installation</code></pre><ol><li><p>输入root用户密码</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230701160809142.png" alt="image-20230701160809142"></p></li><li><p>输入新密码，</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230701161032743.png" alt="image-20230701161032743"></p></li><li><p>输入完后</p><p>设置完新密码后，会直接进入安装配置环节。或是按 CTRL+C 终止上次操作再重新执 行，不要选择修改密码即可。 在进行 MySQL 数据库初始化过程中会出现以下交互确认信息： </p><p>①Change the password for root ? ((Press y|Y for Yes, any other key for No) 表示是否更改 root 用户密码，如果已经修改密码为 Password123$，则直接回车；如果密 码没有修改，可以点 y 在键盘输入 y 和回车。 </p><p>②Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) 表示是否使用设定的密码继续，在键盘输入 y 和回车。</p><p> ③Remove anonymous users? (Press y|Y for Yes, any other key for No) 表示是否删除匿名用户，在键盘输入 y 和回车。 </p><p>④Disallow root login remotely? (Press y|Y for Yes, any other key for No) 表示是否拒绝 root 用户远程登录，在键盘输入 n 和回车，表示允许 root 用户远程登录。 </p><p>⑤Remove test database and access to it? (Press y|Y for Yes, any other key for No) 表示是否删除测试数据库，在键盘输入 y 和回车。test 库在 MySQL 中特殊存在，一般部署 完 mysql 后应当删除该库，并规定不能创建以 test 和 test_字符开头的数据库。因为在 my sql 中，test 库对任意用户都有管理员权限，会造成安全问题。 </p><p>⑥Reload privilege tables now? (Press y|Y for Yes, any other key for No) 表示是否重新加载授权表，在键盘输入 y 和回车。</p></li></ol><h2 id="进入mysql"><a href="#进入mysql" class="headerlink" title="进入mysql"></a>进入mysql</h2><pre><code>mysql -uroot -p</code></pre><h2 id="将数据库的编码全部改成utf-8"><a href="#将数据库的编码全部改成utf-8" class="headerlink" title="将数据库的编码全部改成utf-8"></a>将数据库的编码全部改成utf-8</h2><ol><li><p>编辑文件</p><pre><code>vim /etc/my.cnf</code></pre></li><li><p>添加以下内容</p><pre><code>character_set_server=utf8</code></pre></li><li><p>重启mysql</p><pre><code>systemctl restart mysqld</code></pre></li><li><p>使用以下命令查看</p><pre><code>show variables like &#39;character%&#39;;</code></pre><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230701162733347.png" alt="image-20230701162733347"></p></li></ol><h2 id="修改数据库密码"><a href="#修改数据库密码" class="headerlink" title="修改数据库密码"></a>修改数据库密码</h2><ol><li><p>使用以下密码修改</p><pre><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Password23_&#39;;</code></pre></li><li><p>刷新数据库趣权限</p><pre><code>flush privileges;</code></pre></li></ol><h2 id="设置数据库远程权限"><a href="#设置数据库远程权限" class="headerlink" title="设置数据库远程权限"></a>设置数据库远程权限</h2><ol><li><p>使用以下命令开启远程访问权限</p><pre><code>grant all privileges on *.* to &#39;root&#39;@&#39;%&#39;identified by &#39;Password123_&#39; with grant option;</code></pre></li><li><p>刷新数据库权限</p><pre><code>flush privileges;</code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>warp</title>
      <link href="/2023/04/09/warp/"/>
      <url>/2023/04/09/warp/</url>
      
        <content type="html"><![CDATA[<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><pre><code>https://github.com/fscarmen/warp//使用以下运行脚本warp-go 运行脚本</code></pre><pre><code>wget -N https://raw.githubusercontent.com/fscarmen/warp/main/warp-go.sh &amp;&amp; bash warp-go.sh</code></pre><ul><li><p>选择  非全局</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230409140012513.png" alt="image-20230409140012513"></p></li><li><p>免费 3</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230409140043324.png" alt="image-20230409140043324"></p><p>执行完毕如果没有warp-go这个命令使用以下命令</p><pre><code>systemctl daemon-reloadreboot</code></pre><p>配置出站规则</p><ul><li>进入路径</li></ul><pre><code>/etc/v2ray-agent/xray/conf</code></pre><ul><li>编辑这两个文件</li></ul><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230409153108748.png" alt="image-20230409153108748"></p><ul><li>文件内容</li></ul><pre><code>nano 09_routing.json</code></pre><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230409153332716.png" alt="image-20230409153332716"></p><pre><code>nano 10_ipv4_outbounds.json </code></pre><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20230409153432041.png" alt="image-20230409153432041"></p><ul><li>如果你只有一个配置文件使用以下配置</li></ul><pre><code>&#123;    &quot;outbounds&quot;:[        &#123;            &quot;tag&quot;:&quot;INTERNET_OUT&quot;,            &quot;protocol&quot;:&quot;freedom&quot;,            &quot;settings&quot;:&#123;                &quot;domainStrategy&quot;:&quot;UseIP&quot;            &#125;        &#125;,        &#123;            &quot;tag&quot;:&quot;WARP-GO_INTERFACE&quot;,            &quot;protocol&quot;:&quot;freedom&quot;,            &quot;settings&quot;:&#123;                &quot;domainStrategy&quot;:&quot;UseIPv4&quot;            &#125;,            &quot;sendThrough&quot;:&quot;172.16.0.2&quot;        &#125;    ],    &quot;routing&quot;:&#123;        &quot;rules&quot;:[            &#123;                &quot;type&quot;:&quot;field&quot;,                &quot;outboundTag&quot;:&quot;WARP-GO_INTERFACE&quot;,                &quot;domain&quot;:[                    &quot;geosite:google&quot;,                    &quot;geosite:netflix&quot;,                    &quot;domain:ip.sb&quot;,                    &quot;domain:openai.com&quot;,                    &quot;domain:ai.com&quot;                ]            &#125;,            &#123;                &quot;type&quot;:&quot;field&quot;,                &quot;outboundTag&quot;:&quot;INTERNET_OUT&quot;,                &quot;network&quot;:&quot;udp,tcp&quot;            &#125;        ]    &#125;,    &quot;dns&quot;:&#123;        &quot;servers&quot;:[            &quot;1.1.1.1&quot;,            &quot;1.0.0.1&quot;        ]    &#125;&#125;</code></pre><p>重启脚本</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>security</title>
      <link href="/2023/04/08/security/"/>
      <url>/2023/04/08/security/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jwt</title>
      <link href="/2023/04/05/jwt/"/>
      <url>/2023/04/05/jwt/</url>
      
        <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="什么是jwt"><a href="#什么是jwt" class="headerlink" title="什么是jwt"></a>什么是jwt</h3><p>Jwt是JSON Web Tokens的简称，从单词可以看出它也是一种token，其实可以理解为一种生成token的框架或规范。既然也是token那我们可以换一种问法，token是什么？为什么要使用token？</p><h3 id="token是什么"><a href="#token是什么" class="headerlink" title="token是什么"></a>token是什么</h3><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码</p><h3 id="为什么使用token"><a href="#为什么使用token" class="headerlink" title="为什么使用token"></a>为什么使用token</h3><p>Token是在客户端维护的一种机制，用于身份认证和授权。它是一个字符串，可以包含有关用户身份和权限的信息。在Web应用程序中，当用户成功登录后，服务器将颁发一个Token，然后将其发送给客户端。以后，客户端将在每个请求的HTTP头中包含该Token。服务器可以使用Token验证请求的来源和请求者的身份和权限。</p><h3 id="session和token有什么区别"><a href="#session和token有什么区别" class="headerlink" title="session和token有什么区别"></a>session和token有什么区别</h3><ol><li>Session和Token的存储位置不同。Session存储在服务器上，可以在服务器端直接修改和更新。Token存储在客户端上，通常使用localStorage或sessionStorage存储在浏览器中。</li><li>Session的存储容量通常比Token大，因为它可以存储更多的用户信息。Token通常只包含有关用户身份和授权的少量信息。</li><li>Session可以在一定时间内保持持久状态，而Token通常在一段时间后过期。</li><li>在Web应用程序中，通常会同时使用Session和Token，以提供更加安全和可靠的身份认证和授权机制。Session通常用于维护用户状态和敏感信息，而Token用于身份验证和授权</li></ol><h3 id="session和Cookie-有什么区别"><a href="#session和Cookie-有什么区别" class="headerlink" title="session和Cookie 有什么区别"></a>session和Cookie 有什么区别</h3><ol><li>存储位置：Session 对象存储在服务器端，而 Cookie 存储在客户端（浏览器）</li><li>数据存储：Session 对象可以存储较大量的数据，通常以键值对的形式保存在服务器的内存或持久化存储中；而 Cookie 的存储容量有限，通常只能存储少量文本数据（4KB左右）。</li><li>安全性：由于 Session 对象存储在服务器端，相对于 Cookie 更安全，因为客户端无法直接修改 Session 数据。Cookie 存储在客户端，容易受到篡改和伪造的风险。</li><li>生命周期：Session 对象的生命周期由服务器管理，可以设置过期时间或依赖用户会话；而 Cookie 可以设置过期时间，也可以设置为会话 Cookie，在关闭浏览器后自动删除。</li></ol><h3 id="如何实现token"><a href="#如何实现token" class="headerlink" title="如何实现token"></a>如何实现token</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><pre><code>   &lt;!--        jwt 依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;            &lt;version&gt;0.9.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.auth0&lt;/groupId&gt;            &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;            &lt;version&gt;3.4.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h3 id="创建jwt工具类"><a href="#创建jwt工具类" class="headerlink" title="创建jwt工具类"></a>创建jwt工具类</h3><pre><code>package com.shanhui.util;import com.auth0.jwt.JWT;import com.auth0.jwt.JWTCreator;import com.auth0.jwt.algorithms.Algorithm;import com.auth0.jwt.interfaces.Claim;import com.auth0.jwt.interfaces.DecodedJWT;import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import java.time.*;import java.util.Date;import java.util.HashMap;import java.util.Map;public class JwtUtil &#123;    // token签名加密密钥    private static final String  secret = &quot;#cai*cai%Vc&quot;;    /**     * 创建token     * @param map     * @return     */    public static String createAccessToken(Map&lt;String,String&gt; map)&#123;        JWTCreator.Builder builder = JWT.create();        // 给签名添加参数        map.forEach((k,v)-&gt;&#123;            builder.withClaim(k,v);        &#125;);        //设置token过期时间        builder.withExpiresAt(new Date(System.currentTimeMillis()+40*60*1000));        //设置token创建时间        builder.withIssuedAt(new Date(System.currentTimeMillis()));        return  builder.sign(Algorithm.HMAC256(secret));    &#125;    /**     * 判断是否可以刷新token     * @param token     * @return     */    public static Boolean canToken(String token)&#123;        DecodedJWT decode = JWT.decode(token);        // 获取token的结束时间        Date expiresAt = decode.getExpiresAt();        // 时间转换成LocalDateTime        Instant instant = expiresAt.toInstant();        ZoneId zoneId = ZoneId.systemDefault();        LocalDateTime localDateTime = instant.atZone(zoneId).toLocalDateTime();        System.out.println(LocalDateTime.now());        // 计算当前时间离结束时间还有多少分钟        Duration between = Duration.between(LocalDateTime.now(),localDateTime);        // token过期时间是40分钟，如果过期时间大于30分钟，不用刷新token，小于30分钟刷新token        if ((between.getSeconds()/60)&gt;30&amp;&amp;(between.getSeconds()/60)&lt;=0)&#123;            return false;        &#125;       return  true;    &#125;    /**     * 刷新token     * @param token     * @return     */    public static String refreshToken(String token)&#123;        DecodedJWT decode = JWT.decode(token);        String account = decode.getClaim(&quot;account&quot;).asString();        String userId = decode.getClaim(&quot;userId&quot;).asString();        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;account&quot;,account);        map.put(&quot;userId&quot;,userId);        return createAccessToken(map);    &#125;    /**     * 获取token的参数     * @param token     * @return     */    public static Map&lt;String,String&gt;  getClaim(String token)&#123;        DecodedJWT decode = JWT.decode(token);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        String account = decode.getClaim(&quot;account&quot;).asString();        String userId = decode.getClaim(&quot;userId&quot;).asString();        map.put(&quot;account&quot;,account);        map.put(&quot;userId&quot;,userId);        return  map;    &#125;    public static void main(String[] args) &#123;        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;account&quot;,&quot;admin&quot;);        map.put(&quot;userId&quot;,&quot;1&quot;);        String accessToken = createAccessToken(map);        System.out.println(&quot;token 创建成功&quot;+accessToken);        System.out.println(canToken(accessToken));        Map&lt;String, String&gt; claim = getClaim(accessToken);        System.out.println(claim.get(&quot;account&quot;));    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="/2022/12/23/spring/"/>
      <url>/2022/12/23/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="1-spring简介"><a href="#1-spring简介" class="headerlink" title="1.spring简介"></a>1.spring简介</h2><h3 id="1-1spring是什么"><a href="#1-1spring是什么" class="headerlink" title="1.1spring是什么"></a>1.1spring是什么</h3><ul><li>​spring是分层的java SE&#x2F;EE应用full-stack轻量级开源框架，以Ioc（Inerse Of Control：反转控制）和AOP（Aspect Oriented Programming:面向切面编程）为内核</li></ul><p></p><h2 id="2-spring快速入门"><a href="#2-spring快速入门" class="headerlink" title="2.spring快速入门"></a>2.spring快速入门</h2><h3 id="2-1开发步骤"><a href="#2-1开发步骤" class="headerlink" title="2.1开发步骤"></a>2.1开发步骤</h3><ol><li><p>导入spring 开发的基本包坐标</p><pre><code>//在pom文件导入&lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;5.3.22&lt;/version&gt; &lt;/dependency&gt;</code></pre></li><li><p>编写Dao接口和实现类</p><pre><code class="spring">package com.cfc.it.spring_ioc.dao;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/15 * Time: 16:48 * 需求：接口 */public interface UserDao &#123;    public void  save();&#125;</code></pre><pre><code>package com.cfc.it.spring_ioc.dao.impl;import com.cfc.it.spring_ioc.dao.UserDao;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/15 * Time: 16:49 * 需求：实现类 */public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;save running...&quot;);    &#125;&#125;</code></pre></li><li><p>创建spring核心配置文件</p><p>在resource下创建spring配置文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;</code></pre></li><li><p>在spring配置文件中配置UserDaoImpl</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    配置spring xml id的名字随便起 class指向UserDao实现类--&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;com.cfc.it.spring_ioc.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre></li><li><p>使用spring 的API获得Bean实例</p><pre><code>package com.cfc.it.spring_ioc.demo;import com.cfc.it.spring_ioc.dao.UserDao;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/15 * Time: 16:56 * 需求： */public class UserDaoDemo &#123;    public static void main(String[] args) &#123;        //使用spring 中ApplicationContext对象创建getBean        ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //参数是spring xml配置的id名称        UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;);        userDao.save();    &#125;&#125;</code></pre></li></ol><h3 id="2-2-spring配置文件"><a href="#2-2-spring配置文件" class="headerlink" title="2.2 spring配置文件"></a>2.2 spring配置文件</h3><h4 id="2-2-1-Bean标签基本配置"><a href="#2-2-1-Bean标签基本配置" class="headerlink" title="2.2.1 Bean标签基本配置"></a>2.2.1 Bean标签基本配置</h4><p>用于配置对象交由spring来创建</p><p>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功</p><ul><li>基本属性<ul><li>id:Bean实例在sping容器中的唯一标识，不能重复</li><li>class：Bean的全限名称</li></ul></li></ul><h4 id="2-2-2Bean标签范围配置"><a href="#2-2-2Bean标签范围配置" class="headerlink" title="2.2.2Bean标签范围配置"></a>2.2.2Bean标签范围配置</h4><p>scop：指对象的作用范围，取值如下</p><table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，单例的</td></tr><tr><td>prototype</td><td>多例的</td></tr><tr><td>request</td><td>web项目中，Spring创建一个Bean的对象，将对象存入到request域中</td></tr><tr><td>session</td><td>web项目中，Spring创建一个Bean的对象，将对象存入到session域中</td></tr><tr><td>global session</td><td>web项目中，应用在Portlet环境，如果没有Portlet环境那么global session相当于session</td></tr></tbody></table><pre><code>//导入测试包  &lt;dependency&gt;     &lt;groupId&gt;junit&lt;/groupId&gt;     &lt;artifactId&gt;junit&lt;/artifactId&gt;     &lt;version&gt;3.8.2&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;    2.配置spring xml文件scope 参数singleton或者 prototype     &lt;bean id=&quot;userDao&quot; class=&quot;com.cfc.it.spring_ioc.dao.impl.UserDaoImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;      3.测试  package com.cfc.it.spring_ioc;import com.cfc.it.spring_ioc.dao.UserDao;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/15 * Time: 17:27 * 需求： */public class SpringTest &#123;    @Test    //测试scope属性    public void text1() &#123;        //使用spring 中ApplicationContext对象创建getBean        ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //参数是spring xml配置的id名称        UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;);        UserDao userDao1 = (UserDao) app.getBean(&quot;userDao&quot;);        //如果spring xml文件中bena参数scope 参数是singleton 两个地址值一样就是单例的        System.out.println(userDao);  //com.cfc.it.spring_ioc.dao.impl.UserDaoImpl@72d818d1        System.out.println(userDao1);  //com.cfc.it.spring_ioc.dao.impl.UserDaoImpl@72d818d1        //如果spring xml文件中bena参数scope 参数是prototype  两个地址值不一样就是多例的        System.out.println(userDao);  //com.cfc.it.spring_ioc.dao.impl.UserDaoImpl@5bcab519        System.out.println(userDao1); //com.cfc.it.spring_ioc.dao.impl.UserDaoImpl@e45f292    &#125;&#125;    </code></pre><p>总结</p><ol><li>当scope的取值为singleton时<ul><li>bean的实例化个数：1个</li><li>bean的实例化时机：当spring核心文件被加载时，实例化配置的bean实例</li><li>Bean的生命周期<ul><li>对象创建：当应用加载，创建容器时，对象就被创建了</li><li>对象运行：只要容器在，对象就一直活着</li><li>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</li></ul></li></ul></li><li>当scope的取值为prototype时<ul><li>Bean的实例化个数：多个</li><li>Bean的实例化时机：当调用getBean()方法时实例化Bean</li><li>Bean的生命周期<ul><li>对象创建：当使用对象时，创建新的对象实例</li><li>对象运行：只要对象在使用中，就一直活着</li><li>对象销毁：当对象长时间不用时，被java的垃圾回收器回收了</li></ul></li></ul></li></ol><h4 id="2-2-3Bean实例化三种方式"><a href="#2-2-3Bean实例化三种方式" class="headerlink" title="2.2.3Bean实例化三种方式"></a>2.2.3Bean实例化三种方式</h4><ul><li><p>无参构造方法实例化</p><ul><li>调用默认时无参构造实例化对象</li></ul></li><li><p>工厂静态方法实例化</p><pre><code>package com.cfc.it.spring_ioc.factoy;import com.cfc.it.spring_ioc.dao.UserDao;import com.cfc.it.spring_ioc.dao.impl.UserDaoImpl;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/30 * Time: 0:35 * 需求： */public class StaticFactory &#123;    //工厂静态方法实例化    private static UserDao getUserDao()&#123;        return new UserDaoImpl();    &#125;&#125; </code></pre><pre><code> #spring配置文件  &lt;bean id=&quot;userDao&quot; class=&quot;com.cfc.it.spring_ioc.factoy.StaticFactory&quot; factory-method=&quot;getUserDao&quot; &gt;&lt;/bean</code></pre></li><li><p>工厂实例方法实例化</p><pre><code>package com.cfc.it.spring_ioc.factoy;import com.cfc.it.spring_ioc.dao.UserDao;import com.cfc.it.spring_ioc.dao.impl.UserDaoImpl;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/30 * Time: 0:47 * 需求： */public class DynamicFactory &#123;    //工厂实例方法实例化    public UserDao getUserDao()&#123;        return new UserDaoImpl();    &#125;&#125;</code></pre><pre><code>&lt;!--    工厂实例方法实例化配置--&gt;    &lt;bean id=&quot;factory&quot; class=&quot;com.cfc.it.spring_ioc.factoy.DynamicFactory&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userDao&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getUserDao&quot;&gt;&lt;/bean&gt;</code></pre></li></ul><h3 id="2-3spring-Bean依赖注入"><a href="#2-3spring-Bean依赖注入" class="headerlink" title="2.3spring Bean依赖注入"></a>2.3spring Bean依赖注入</h3><ul><li><p>​依赖注入（dependency Injection）：它是spring框架核心IOC的具体实现</p></li><li><p>在编写程序时，通过控制反转，把对象的创建交给了spring，但是代码中不可能出现没有依赖情况</p><p>IOC解耦只是减低它们的依赖关系，但不会消除。列如：业务层会调用持久层</p></li><li><p>那这种业务层和持久层的依赖关系，在使用spring之后，就让spring维护了</p><p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取</p></li></ul><h4 id="2-3-1Bean依赖注入方式"><a href="#2-3-1Bean依赖注入方式" class="headerlink" title="2.3.1Bean依赖注入方式"></a>2.3.1Bean依赖注入方式</h4><p>怎么将UserDao怎么样注入到UserService内部呢？</p><p>dao层</p><pre><code>package com.cfc.it.spring_ioc.dao.impl;import com.cfc.it.spring_ioc.dao.UserDao;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/15 * Time: 16:49 * 需求： */public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;save running...&quot;);    &#125;&#125;</code></pre><pre><code>package com.cfc.it.spring_ioc.dao;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/15 * Time: 16:48 * 需求： */public interface UserDao &#123;    public void  save();&#125;</code></pre><ul><li><p>构造方法</p><ul><li><p>service层</p><pre><code>package com.cfc.it.spring_ioc.service.impl;import com.cfc.it.spring_ioc.dao.UserDao;import com.cfc.it.spring_ioc.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/30 * Time: 1:05 * 需求： */public class UserServiceImpl implements UserService &#123;    //这时候通过构造方法依赖注入，这里配置了但是spring不知道    //需要在spring 配置文件配置    private UserDao userDao;    public UserServiceImpl(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    public UserServiceImpl() &#123;    &#125;    @Override    public void service() &#123;        userDao.save();    &#125;&#125;</code></pre><pre><code>package com.cfc.it.spring_ioc.service;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/30 * Time: 1:04 * 需求： */public interface UserService &#123;        public void service();&#125;</code></pre></li><li><p>controller</p><pre><code>package com.cfc.it.spring_ioc.controller;import com.cfc.it.spring_ioc.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created with IntelliJ IDEA. * creator:  * Date: 2022/10/30 * Time: 1:08 * 需求： */public class UserController &#123;    public static void main(String[] args) &#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);        userService.service();    &#125;&#125;</code></pre></li><li><p>xml配置</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    配置spring xml id的名字随便起 class指向UserDao实现类--&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;com.cfc.it.spring_ioc.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.cfc.it.spring_ioc.service.impl.UserServiceImpl&quot;&gt;        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre></li></ul></li><li><p>set方法</p><ul><li><p>service层</p><pre><code>package com.cfc.it.spring_ioc.service.impl;import com.cfc.it.spring_ioc.dao.UserDao;import com.cfc.it.spring_ioc.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/30 * Time: 1:05 * 需求： */public class UserServiceImpl implements UserService &#123;    //这时候通过set方法依赖注入，这里配置了但是spring不知道    //需要在spring 配置文件配置property    private UserDao userDao;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void service() &#123;        userDao.save();    &#125;&#125;</code></pre><pre><code>package com.cfc.it.spring_ioc.service;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/30 * Time: 1:04 * 需求： */public interface UserService &#123;        public void service();&#125;</code></pre></li><li><p>controller</p><pre><code>package com.cfc.it.spring_ioc.controller;import com.cfc.it.spring_ioc.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created with IntelliJ IDEA. * creator:  * Date: 2022/10/30 * Time: 1:08 * 需求： */public class UserController &#123;    public static void main(String[] args) &#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);        userService.service();    &#125;&#125;</code></pre></li><li><p>xml配置</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    配置spring xml id的名字随便起 class指向UserDao实现类--&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;com.cfc.it.spring_ioc.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.cfc.it.spring_ioc.service.impl.UserServiceImpl&quot;&gt;                    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><ul><li><p>set方法注入xml配置P命名空间注入</p><ul><li><p>P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中：如下</p><p>首先，需要引入P命名空间</p><pre><code>xmlns:p=&quot;http://www.springframework.org/schema/p</code></pre><p>其次，需要修改注入方式</p><pre><code>&lt;bean id=&quot;userService&quot; class=&quot;com.cfc.it.spring_ioc.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;&gt;&lt;/bean&gt;</code></pre></li></ul></li></ul></li></ul></li></ul><h4 id="2-3-2Bean的依赖注入的数据类型"><a href="#2-3-2Bean的依赖注入的数据类型" class="headerlink" title="2.3.2Bean的依赖注入的数据类型"></a>2.3.2Bean的依赖注入的数据类型</h4><ul><li><p>注入数据的三种数据类型</p><ul><li><p>普通数据类型</p><p>dao</p><pre><code>package com.cfc.it.spring_ioc.dao.impl;import com.cfc.it.spring_ioc.dao.UserDao;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/15 * Time: 16:49 * 需求： */public class UserDaoImpl implements UserDao &#123;    private String username;    private int age;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public void save() &#123;        System.out.println(username+&quot;====&quot;+age);        System.out.println(&quot;save running...&quot;);    &#125;&#125;</code></pre><pre><code>&lt;!--    配置spring xml id的名字随便起 class指向UserDao实现类--&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;com.cfc.it.spring_ioc.dao.impl.UserDaoImpl&quot;&gt;        &lt;property name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;     &lt;/bean&gt;</code></pre></li><li><p>引用数据类型</p><ul><li>就是之前的userDao注入到userService就是引用数据类型</li></ul></li><li><p>集合数据类型</p><pre><code>package com.cfc.it.spring_ioc.dao.impl;import com.cfc.it.spring_ioc.dao.UserDao;import com.cfc.it.spring_ioc.model.User;import java.util.List;import java.util.Map;import java.util.Properties;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/15 * Time: 16:49 * 需求： */public class UserDaoImpl implements UserDao &#123;    private List&lt;String&gt; list;    private Map&lt;String, User&gt; userMap;    private Properties properties;    public List&lt;String&gt; getList() &#123;        return list;    &#125;    public void setList(List&lt;String&gt; list) &#123;        this.list = list;    &#125;    public Map&lt;String, User&gt; getUserMap() &#123;        return userMap;    &#125;    public void setUserMap(Map&lt;String, User&gt; userMap) &#123;        this.userMap = userMap;    &#125;    public Properties getProperties() &#123;        return properties;    &#125;    public void setProperties(Properties properties) &#123;        this.properties = properties;    &#125;    @Override    public void save() &#123;        System.out.println(list);        System.out.println(userMap);        System.out.println(properties);        System.out.println(&quot;save running...&quot;);    &#125;&#125;</code></pre><pre><code>&lt;!--    配置spring xml id的名字随便起 class指向UserDao实现类--&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;com.cfc.it.spring_ioc.dao.impl.UserDaoImpl&quot;&gt;&lt;!--        集合list注入--&gt;        &lt;property name=&quot;list&quot;&gt;            &lt;list&gt;                &lt;value&gt;aaa&lt;/value&gt;                &lt;value&gt;ccc&lt;/value&gt;                &lt;value&gt;ddd&lt;/value&gt;                &lt;value&gt;bbb&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;&lt;!--        集合map注入--&gt;        &lt;property name=&quot;userMap&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;u1&quot; value-ref=&quot;user&quot;&gt;&lt;/entry&gt;                &lt;entry key=&quot;u2&quot; value-ref=&quot;user2&quot;&gt;&lt;/entry&gt;            &lt;/map&gt;        &lt;/property&gt;    &lt;property name=&quot;properties&quot; &gt;        &lt;props&gt;            &lt;prop key=&quot;dddd&quot;&gt;1&lt;/prop&gt;            &lt;prop key=&quot;dda&quot;&gt;2&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;     &lt;/bean&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.cfc.it.spring_ioc.model.User&quot;&gt;        &lt;property name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;user2&quot; class=&quot;com.cfc.it.spring_ioc.model.User&quot;&gt;        &lt;property name=&quot;username&quot; value=&quot;lisi&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre></li></ul></li></ul><h4 id="2-3-4标签：导入其他的spring分件"><a href="#2-3-4标签：导入其他的spring分件" class="headerlink" title="2.3.4标签：导入其他的spring分件"></a>2.3.4<import>标签：导入其他的spring分件</h4><ul><li>在实际开发中有很多配置但是只有一个主文件，那么我们份文件配置可以使用以下import引入</li></ul><pre><code> &lt;import resource=&quot;applicationContext_user.xml&quot;&gt;&lt;/import&gt;</code></pre><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20221030230947237.png" alt="image-20221030230947237"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20221030231228880.png" alt="image-20221030231228880"></p><h2 id="3-spring相关API"><a href="#3-spring相关API" class="headerlink" title="3.spring相关API"></a>3.spring相关API</h2><ul><li><p>ClassPathXmlApplicationContext</p><pre><code> ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></pre></li><li><p>FileSystemXmlApplicationContext</p><pre><code>ApplicationContext applicationContext = new FileSystemXmlApplicationContext(&quot;D:\\课上\\JAVA\\spring\\spring_ioc\\src\\main\\resources\\applicationContext.xml&quot;);</code></pre></li></ul><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20221030231643599.png" alt="image-20221030231643599"></p><h2 id="4-spring配置数据源"><a href="#4-spring配置数据源" class="headerlink" title="4.spring配置数据源"></a>4.spring配置数据源</h2><h3 id="4-1数据源（连接池）的作用"><a href="#4-1数据源（连接池）的作用" class="headerlink" title="4.1数据源（连接池）的作用"></a>4.1数据源（连接池）的作用</h3><ul><li>数据源（连接池）是提高程序性能如出现的</li><li>事先实例化数据源，初始化部分连接资源</li><li>使用连接资源时从数据源获取</li><li>使用完毕后将i按揭资源归还给数据源</li></ul><p>常见数据源（连接池）：DBCP、C3P0、BoneCP、Druid等</p><h3 id="4-2数据源的开发步骤"><a href="#4-2数据源的开发步骤" class="headerlink" title="4.2数据源的开发步骤"></a>4.2数据源的开发步骤</h3><ul><li>导入数据源的坐标和数据库驱动坐标</li><li>创建数据源的对象</li><li>设置数据源的基本连接数据</li><li>使用数据源获取连接资源和归还连接资源</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2022/12/18/demo/"/>
      <url>/2022/12/18/demo/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>来源：力扣（LeetCode）</p><pre><code> public static void main(String[] args) &#123;       int[] nums = &#123;3,2,4&#125;;       int target = 6;        System.out.println(Arrays.toString(twoSum(nums, target)));    &#125;方法一:    public static int[] twoSum(int[] nums, int target) &#123;        int[] newNums= new int[2];        // 第一次遍历，需要循环多少次        for (int i = 0; i &lt; nums.length; i++) &#123;            for (int j = i+1; j &lt; nums.length; j++) &#123;                // 判断第一次循环的i和第二次循环的j进行相加等于target                if (nums[i]+nums[j]==target)&#123;                    //存入数据到新数据中                    newNums[0]= i;                    newNums[1] = j;                &#125;            &#125;        &#125;        return newNums;    &#125;));                方法二:  Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();        for (int i = 0; i &lt; nums.length; ++i) &#123;            // containsKey检查key是否存在，第一次循环key肯定是不存在，如果存在证明集合中的key+当前nums[i]等于target            if (hashtable.containsKey(target - nums[i])) &#123;                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;            &#125;            // 给hashMap中存入数据key是当前的值，值是当前索引            hashtable.put(nums[i], i);            System.out.println(hashtable);        &#125;        return new int[0];        </code></pre><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p>来源：力扣（LeetCode）<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><img src="D:\project\blogImage\image-20221225130224012.png" alt="image-20221225130224012"></p><pre><code>package leetcode;public class Solution &#123;    public static void main(String[] args) &#123;        System.out.println(maxArea(new int[]&#123;1,8,6,2,5,4,8,3,7&#125;));    &#125;//    盛最多水的容器    public static int maxArea(int[] height) &#123;       // 定义两个变量，使用双指针        int start=0;        int end = height.length-1;        //在定义一个变量，记录容器的面积        int rectangle = 0;        while (start!=end)&#123;            if (height[start]&gt;=height[end]) &#123;                rectangle = Math.max(rectangle,Math.min(height[start],height[end])*(end-start));                end--;            &#125;else &#123;                rectangle = Math.max(rectangle,Math.min(height[start],height[end])*(end-start));                start++;            &#125;        &#125;        return rectangle;    &#125;&#125;</code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请</p><p>你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/3sum">https://leetcode.cn/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><img src="D:\project\blogImage\image-20221230123127008.png" alt="image-20221230123127008"></p><pre><code>    public static void main(String[] args) &#123;        System.out.println(threeSum(new int[]&#123;-1, 0, 1, 2, -1, -4&#125;));    &#125;</code></pre><pre><code>    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();        // 获取数组的长度        int len = nums.length;        // 如果数组为null或者小于等于3那么直接返回空列表        if (nums==null || len&lt;3) return list;        // 从小到大排序        Arrays.sort(nums);        System.out.println(Arrays.toString(nums));        // 遍历数组中的每一个元素        for (int i = 0; i &lt; len; i++) &#123;            // 如果起始值大于0那么直接停止循环，因为大于0那么三数相加也是大于0，不符合题目            if (nums[i]&gt;0)&#123;                break;            &#125;            // 如果起始值等于前一个值那么直接跳过这次循环，因为他们相加和前一次都相同都一样            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;            int j = i+1;            int k = len-1;            //如果j=k那么就停止循环，j&lt;k循环相加            while (j&lt;k)&#123;                int sum = nums[i]+nums[j]+nums[k];                System.out.println(&quot;nums[&quot;+i+&quot;] +&quot;+&quot; nums[&quot;+j+&quot;] + &quot;+&quot; nums[&quot;+k+&quot;] =&quot;+(nums[i]+nums[j]+nums[k]));                // 判断相加值是否等于0                if (sum==0)&#123;                    // 如果等于0就添加刀数组里面                    list.add(Arrays.asList(nums[i],nums[j],nums[k]));                    while (j&lt;k&amp;&amp;nums[j]==nums[j+1]) j++;                    while (j&lt;k&amp;&amp;nums[k]==nums[k-1]) k--;                    j++;                    k--;                    //如果sum值小于0左指针++                &#125; else if (sum&lt;0) &#123;                    j++;                    //如果sum值大于0右指针--                &#125;else if (sum&gt;0)&#123;                    k--;                &#125;            &#125;        &#125;        return list;    &#125;</code></pre><p>最接近的三数之和</p><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/3sum-closest">https://leetcode.cn/problems/3sum-closest</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><img src="D:\project\blogImage\image-20221230140958281.png" alt="image-20221230140958281"></p><pre><code>            while (l &lt; r) &#123;                int sum = nums[i] + nums[l] + nums[r];                // 如果sum的值等于target则直接返回sum                if (sum == target) return sum;                // 如果sum值大于target，那么r--，因为上面从小到大排序，起始值+（起始值+1）+r的值都是大于target所以直接r--                if (sum &gt; target) &#123;                    if ((sum - target) &lt; cha) &#123;                        res = sum;                        cha = sum - target;                    &#125;                    // nums[r] == nums[r - 1] 其实相加都一样直接在--                    while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--;                    r--;                &#125; else &#123;                    if ((target - sum) &lt; cha) &#123;                        res = sum;                        cha = target - sum;                    &#125;                    while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++;                    l++;                &#125;            &#125;        &#125;        return res;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2022/12/16/JAVA/"/>
      <url>/2022/12/16/JAVA/</url>
      
        <content type="html"><![CDATA[<p>java之父—高斯林</p><p>Java的发展可以分为以下几个阶段：</p><ol><li><p>1995年：Java语言的诞生。</p></li><li><p>1996年：Java 1.0版本的发布。</p></li><li><p>1997年：Java 1.1版本的发布，新增了事件处理模型等功能。</p></li><li><p>1999年：Java 2 Platform Standard Edition 1.2版本的发布，支持动态Web内容。</p></li><li><p>2002年：Java 2 Platform Standard Edition 1.4版本的发布，引入了注解、NIO等新特性。</p></li><li><p>2004年：Java 5.0版本的发布，引入了泛型、可枚举类型等特性。</p></li><li><p>2006年：Java 6版本的发布，改进了XML处理、并行计算等方面。</p></li><li><p>2011年：Java 7版本的发布，增加了语言级别的支持。</p></li><li><p>2014年：Java 8版本的发布，引入了Lambda表达式、Streams API等新特性。</p></li><li><p>2018年：Java 10版本的发布，带来了更多的语言和性能改进。</p></li><li><p>JDK是什么？有哪些内容组成？</p><p>​           JDK是java开发工具包</p><ul><li>​JVM虚拟机：java程序运行的地方</li><li>核心类库：java已经写好的东西，我们可以直接用。</li><li>开发工具：javac、java、jdb、jhat</li></ul></li><li><p>JRE是什么？有哪些内容组成？</p><p>JRE是java运行环境</p><p>JVM、核心类库、运行工具</p></li><li><p>JDk、JRE、JVM三者包含关系</p><ul><li>JDK包含JRE</li><li>JRE包含JVM</li></ul></li></ol><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul><li>在ACIIL表中字符’1’对应的数字是49，字符’0’对应的字符是48，这两个字符’1’-‘0’等于数字1</li></ul><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>隐式转换小结</p><ol><li><p>取值范围</p><p>byte&lt;short&lt;int&lt;long&lt;float&lt;double</p></li><li><p>什么时候转换</p><p>数据类型不一样，不能计算，需要转成一样的数据类型才可以计算</p></li><li><p>转换规则1：</p><p>取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算</p></li><li><p>转换规则2</p><p>byte short char 三种类型的数据在运算的时候，都会直接先提升到int，然后再进行运算</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220919165559479.png" alt="image-20220919165559479"></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>数组定义</p><ul><li>数据类型[]   数组名 &#x3D;  new 数据类型[]{元素1，元素2，元素3}</li><li>数据类型[]  数组名 &#x3D; {}</li></ul><p>例：</p><pre><code class="java">//        定义数组存储5个学生年龄        int[] arr = &#123;15,17,16,13&#125;;        int[] ar1 = new int[]&#123;15,17,16,13&#125;;        System.out.println(arr);  //[I@1b6d3586        System.out.println(ar1);  //[I@4554617c        //扩展        //解释数组的地址值  //[I@1b6d3586        //[ : 表示当前是一个数组        //I ： 表示当前数组里面的元素都是int类型        //@ ： 表示一个间隔符。固定格式        //1b6d3586：才是数组真正的地址。（十六进制）        //平时会把整个叫做数组地址值</code></pre></li><li><p>java内存分配</p><ul><li>java运行是虚拟机也会占用内存，但是为了更好的利用这块内存，虚拟机又分配了5个部分，每个部分都有它自己的作用</li></ul><p>​     <img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902133323410.png" alt="image-20220902133323410" style="zoom:67%;" /></p><ul><li>jdk7以前方法区和堆是连在一起的</li></ul><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902162900225.png" alt="image-20220902162900225" style="zoom:67%;" /><ul><li><p>注意：从jdk8开始取消了方法区，新增了元空间。把原来方法区的多种功能进行拆分，有的功能放在队中有的功能放在元空间中</p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902163809082.png" alt="image-20220902163809082" style="zoom:67%;" /></li></ul></li><li><ul><li>栈   方法运行使用的内存，比如main方法运行，进入栈内存中</li><li>堆   存储对象或数组，只要new来创建的都进入堆内存中</li><li>方法区   存储可以运行class文件</li><li>本地方法栈   jvm使用操作系统的功能是使用，与开发无关</li><li>寄存器  给cpu使用，与开发无关</li></ul></li><li><p>数组内存分配</p><ul><li><p>只要是new出来的一定是在堆里面开辟一个小空间</p></li><li><p>如歌new了多次，那么堆里就有多少个小空间，而且每个小空间都有各自的数据</p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902165249568.png" alt="image-20220902165249568" style="zoom:67%;" /></li><li><p>当两个数组指向同一个空间的，其中一个数组对空间数据中的值发生改变，那么其他数据再次访问的时候都是修改之后的结果</p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902165249568.png" alt="image-20220902165249568" style="zoom:67%;" /></li></ul></li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>什么是方法</p><p>方法是程序中最小的执行单元</p><ol><li><p>实际开发中，什么时候用到方法？</p><p>​重复的代码，具有独立功能的代码可以抽到方法中</p></li><li><p>实际开发中，方法有什么好处</p></li></ol><p>​            提高代码的复用性</p><p>​提高代码的维护</p></li><li><p>方法的格式</p><ul><li><p>最简单的方法定义</p><ul><li>方法的定义</li></ul><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902171840717.png" alt="image-20220902171840717" style="zoom:67%;" /><ul><li><p>方法的调用</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902172119284.png" alt="image-20220902172119284"></p><pre><code class="java">package Day;public class Day04 &#123;    public static void main(String[] args) &#123;        //方法的调用        playGame();        /**         * 练习         *定义一个方法，在方法中定义两个变量进行求和         */        sum();    &#125;    /**     * 注意：定义方法是在main主方法外面，但是方法的调用在主方法里面     */    //定义一个方法    public static void playGame()&#123;        System.out.println(&quot;准备&quot;);        System.out.println(&quot;确定&quot;);        System.out.println(&quot;操作&quot;);        System.out.println(&quot;结束&quot;);    &#125;    //定义一个求和的方法    public  static  void sum()&#123;        int a = 10;        int b = 20;        int result = a+b;        System.out.println(result);    &#125;&#125;</code></pre></li></ul></li><li><p>带参数的方法定义</p><ul><li><p>带参数方法的定义</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902210944199.png" alt="image-20220902210944199"></p></li><li><p>带参数方法发调用</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902211057405.png" alt="image-20220902211057405"></p></li></ul><pre><code></code></pre><ul><li><p>形参和实参</p><ul><li><p>形参：全称形式参数，是指方法定义中的参数</p></li><li><p>实参：全称实际参数，是指调用的参数</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902211724508.png" alt="image-20220902211724508"></p></li></ul><pre><code>    public static void main(String[] args) &#123;        //调用求长方形的周长，将结果在方法中进行        rectangle(5.5,6.5);        //调用求圆的面积，将结果在方法中打印        circle(4.0);    &#125;            //定义一个长方形周长方法    public static void rectangle(double len,double width)&#123;        double result = (len+width)*2;        System.out.println(result);    &#125;    //定义一个求圆的面积    public static void circle(double r)&#123;        double S = 3.14*(r*r);        System.out.println(S);    &#125;</code></pre></li></ul></li><li><p>带返回值的方法定义</p><ul><li><p>带返回值方法的定义</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220902220113515.png" alt="image-20220902220113515"></p></li><li><p>带返回值方法的调用</p></li></ul><pre><code>    public static void main(String[] args) &#123;        //调用长方形面积        double are = getAre(3.0, 4.0);        double are1 = getAre(4.0, 3.0);        if (are &gt; are1)&#123;            System.out.println(&quot;第一个长方形面积大于第二个长方形面积&quot;);        &#125;else &#123;            System.out.println(&quot;第二个长方形面积大于第一个长方形面积&quot;);        &#125;    &#125;            //定义一个求长方形面积的方法    public  static double getAre(double len,double width)&#123;        double res = len*width;        return res;    &#125;</code></pre><ul><li>方法的注意事项<ul><li>方法不调用就不执行</li><li>方法与方法之间是平级关系，不能互相嵌套</li><li>方法的编写顺序和执行顺序无关，根据方法调用顺序有关</li><li>方法的返回值类型为void，表示该方法没有返回值，没有返回值的方法可以省略return语句不写。如果要编写编写return，后面不能跟具体的数据。</li><li>return语句下面，不能编写代码，因为永远执行不到，属于无效代码</li></ul></li><li>return关键字<ul><li>方法没有返回值：可以省略不写。如果书写，表示结束方法</li><li>方法有返回值：必须要写。表示结束方法和返回结果是</li></ul></li></ul></li></ul></li><li><p>方法的重载</p><ul><li><p>什么是方法的重载</p><ul><li>在同一个类中，定义了多个同名的方法，这些同名的方法具有同种的功能</li><li>每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系</li></ul><p>简单机：同一个类中，方法名相同参数不同的方法。与返回值无关</p><p>​参数不同：个数不同、类型不同、顺序不同</p></li></ul></li><li><p>方法的内存</p><ul><li>方法调用的基本内存原理</li><li>方法传递基本数据类型原理<ul><li>基本数据类型：变量存储的都是真是数据<ul><li>整数类型</li><li>浮点数类型</li><li>布尔类型</li><li>字符类型</li></ul></li><li>引用数据类型：在栈内记录的是地址值，使用其他空间的数据<ul><li>除了上面基本数据类型都是</li></ul></li></ul></li><li>方法传递引用数据类型的内存原理</li></ul></li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li><p>设计对象并使用</p><ul><li><p>类和对象： 必须先设计类才能获取对象</p><ul><li>类（设计图）:是对象共同特征的描述</li><li>对象：是真实存在的具体东西</li></ul></li><li><p>类的几个注意事项</p><ul><li>用来描述一类事物的类，专业叫做：javabean类。在javabean类中，是不写mian方法的。</li><li>在以前。编写mian方法的类，叫做测试类。我们可以在测试类中创建Javabean类对象并进行赋值调用。</li></ul></li><li><p>总结</p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220904100155619.png" alt="image-20220904100155619" style="zoom:67%;" /><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220904100217142.png" alt="image-20220904100217142" style="zoom:67%;" /></li></ul></li><li><p>封装</p><p>- </p></li><li><p>this关键字</p><ul><li>可以区别成员变量和局部变量</li></ul></li><li><p>构造方法</p><ul><li>作用：<ul><li>创建对象的时候，由虚拟机自动调用，给成员变量进行初始化的。</li></ul></li><li>特点：<ul><li>方法名与类名相同，大小写也要一致</li><li>没有返回值类型，连void都没有</li><li>没有具体的返回值（不能由retrun带回结果的数据）</li></ul></li><li>构造方法有几种，各自的作用是什么。<ul><li>无参数构造方法：初始化对象是，成员变量的数据均采用默认值。</li><li>有参数构造方法：在初始对象时候，同时可以为对象进行赋值。</li></ul></li><li>执行时机<ul><li>创建对象的时候由虚拟机调用，不能手动调用构造方法</li><li>每创建一次对象，就会调用一次构造方法</li></ul></li><li>构造方法定义<ul><li>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</li><li>如果定义构造方法，系统将不再提供默认的构造方法</li></ul></li><li>构造方法的重载<ul><li>带参构造方法，和无参构造方法，两者方法名相同但是参数不同，这叫做构造方法的重载</li></ul></li><li>推荐的使用方式<ul><li>无论是否使用，都手动书写无参数构造的方法，和带全部参数的构造方法</li></ul></li><li>构造方法有哪些注意事项<ul><li>任何类定义出来，默认自带了无参数构造器，写不写都有。</li><li>一旦定义了有参数构造器，无参数构造器就没有了，此时就需要自己写无参数构造器了。</li><li>建议在任何时候都手动写上空参和带全部参数的构造方法</li></ul></li></ul></li><li><p>标准javaBean</p><ul><li>类名需要见名知意</li><li>成员变量使用private修饰</li><li>提供至少两个构造方法、<ul><li>无参构造方法</li><li>有参构造方法</li></ul></li><li>成员方法<ul><li>提供每一个成员变量对应的setXxx()&#x2F;getXxx()</li><li>如果还要其他行为，也需要写上</li></ul></li></ul></li><li><p>对象内存图</p><ul><li><p>一个对象的内存图</p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220904110844634.png" alt="image-20220904110844634" style="zoom: 50%;" /></li><li><p>多个对象的内存图</p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220904111831605.png" alt="image-20220904111831605" style="zoom: 50%;" /></li><li><p>两个引用指向同一个对象的内存图</p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220904111856074.png" alt="image-20220904111856074" style="zoom:50%;" /></li><li><p>this的内存图原理</p><ul><li>this的作用:区分局部变量和成员变量</li><li>this的本质：所在方法调用者的地址值</li></ul></li><li><p>基本数据类型和引用数据类型的区别</p></li><li><p>局部变量和成员变量的区别</p></li></ul></li><li><p>补充知识：成员变量、局部变量区别</p><ul><li>成员变量：类中方法外的变量</li><li>局部变量：类中方法内的变量</li></ul><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220904162404297.png" alt="image-20220904162404297"></p></li><li><p>修饰符</p><ul><li>private<ul><li>是一个权限修饰符</li><li>可以修饰成员（成员变量和成员方法）</li><li>被private修饰的成员只能在本类中才能访问</li></ul></li></ul></li></ul><p>练习</p><pre><code class="java">package Day.dayMxdx;/** * 定义一个长度为3的数组，数组存储1~3名学生对象作为初始化数据，学生对象的学号，姓名各不相同。 * 学生属性：学号，姓名，年龄 * 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一判断 * 要求二：添加完毕之后遍历所有学生信息 * 要求三：通过id删除，如果不存在，则提示删除失败 * 要求四：删除后遍历所有学生信息 * 要求五：查询数组id为“heima002”的学生，如果存在，则将他年龄+1； */public class Student &#123;    private String id;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String id, String name, int age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;//测试类package Day.dayMxdx;/** * 定义一个长度为3的数组，数组存储1~3名学生对象作为初始化数据，学生对象的学号，姓名各不相同。 * 学生属性：学号，姓名，年龄 * 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一判断 * 要求二：添加完毕之后遍历所有学生信息 * 要求三：通过id删除，如果不存在，则提示删除失败 * 要求四：删除后遍历所有学生信息 * 要求五：查询数组id为“heima002”的学生，如果存在，则将他年龄+1； */public class StudentTest &#123;    public static void main(String[] args) &#123;        //定义一个长度为3的数组        Student[] arr = new  Student[3];        //定义对象        Student s1 = new Student(&quot;001&quot;,&quot;小明&quot;,18);        Student s2 = new Student(&quot;002&quot;,&quot;小东&quot;,20);        Student s3 = new Student(&quot;003&quot;,&quot;小蔡&quot;,22);        //数组存储1~3名学生对象作为初始化数据        arr[0] = s1;        arr[1] = s2;        arr[2] = s3;        //再次添加一个对象到数组里面        Student s4 = new Student(&quot;004&quot;,&quot;小第&quot;,28);//        调用判断方法        Boolean flag = repetition(arr, s4.getId());        if (flag)&#123;            System.out.println(&quot;数组里面已经存在id，请重新跟换id在添加&quot;);        &#125;else &#123;            int count = getCount(arr);            //如果相等则数组长度不够            if (count==arr.length)&#123;                //重新创建数组                Student[] createArr = createArr(arr);                createArr[count] = s4;                for (int i = 0; i &lt; createArr.length; i++) &#123;                    Student student = createArr[i];                    System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge());                &#125;            &#125;else &#123;                arr[count] = s4;            &#125;        &#125;        //根据id删除        int index = getId(arr, &quot;002&quot;);        if (index == -1) &#123;            System.out.println(&quot;数组没有这个id，删除失败&quot;);        &#125;else&#123;            Student[] students = deleteArray(arr,index);            System.out.println(&quot;删除成功&quot;);            for (int i = 0; i &lt; students.length; i++) &#123;                Student student = students[i];                System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge());            &#125;        &#125;        //查询数组id为“heima002”的学生，如果存在，则将他年龄+1        //根据id删除        int indexs = getId(arr, &quot;003&quot;);        if (indexs == -1) &#123;            System.out.println(&quot;数组没有这个id&quot;);        &#125;else&#123;            Student student = arr[indexs];            System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+(student.getAge()+1));        &#125;    &#125;    //定义一个方法判断数组数据    public static  int getCount(Student[] arr)&#123;        int count = 0;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.println(arr[i]);            if (arr[i]!=null)&#123;                count++;            &#125;        &#125;        return count;    &#125;    //定义一个方法，判断数组里面是否有重复的数据    public static Boolean  repetition(Student[] arr, String id)&#123;        for (int i = 0; i &lt; arr.length; i++) &#123;            Student student = arr[i];            if (student.getId()==id)&#123;                return true;            &#125;        &#125;        return  false;    &#125;        //定义一个如果数组长度不够，重新创建数组，然后数组长度等于旧数组的长度+1    public static  Student[]  createArr(Student[] arr)&#123;        Student[] createArr = new Student[arr.length+1];        for (int i = 0; i &lt; arr.length; i++) &#123;            createArr[i] = arr[i];        &#125;        return createArr;    &#125;    //定义一个方法根据id查询出索引的位置    public  static  int getId(Student[] arr, String id)&#123;        int count = -1;        for (int i = 0; i &lt; arr.length; i++) &#123;            Student s = arr[i];            if (s.getId()==id)&#123;                count = i;                break;            &#125;        &#125;        return count;    &#125;    //定义一个方法删除数组元素    public static  Student[] deleteArray(Student[] arr,int index)&#123;        Student[] newArray = new  Student[arr.length-1];        for (int i = 0; i &lt; newArray.length; i++) &#123;            if (index&lt;0 || index &gt; arr.length)&#123;                System.out.println(&quot;数组越界&quot;);            &#125;            if (i&lt;index)&#123;                newArray[i] = arr[i];            &#125;else &#123;                newArray[i] = arr[i+1];            &#125;        &#125;        System.out.println(newArray.length);        return  newArray;    &#125;&#125;</code></pre><h4 id="API和API文档"><a href="#API和API文档" class="headerlink" title="API和API文档"></a>API和API文档</h4><ul><li><p>API文档：应用程序编程接口</p><ul><li>简单理解：API就是别人已经写好的东西，我们不需要自己编写，直接使用即可</li></ul></li><li><p>Java API：指的就是JDK中提供的各种功能的java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。</p></li><li><p>String</p><ul><li><p>字符串的内容是不会发生改变的，它的对象创建后不能被更改</p></li><li><p>创建String对象的两种方式</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220907145255890.png" alt="image-20220907145255890"></p></li><li><p>String内存模型</p><ul><li><p>当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。</p><ul><li>不存在：创新的</li><li>存在：复用</li></ul><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220907145634099.png" alt="image-20220907145634099"></p></li><li><p>当使用new创建赋值是</p><ul><li>每new一个就会在堆里面创建小空间，不会使用Strin Table(串池)，这样会大量的使用内存</li></ul><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220907145839923.png" alt="image-20220907145839923"></p></li><li><p>字符串之间比较</p><ul><li><p>第一个方式创建和第二个方式new出来的用&#x3D;&#x3D;于比较是等于false，因为它们比较的是地址值</p><pre><code class="java">String name = &quot;dasdadas&quot;;    //进入内存的串池String names =  &quot;dasdadas&quot;; System.out.println(name==names);  //true String n = new String(&quot;dasdadas&quot;);   //直接在堆空间中生成小空间        System.out.println(name==n);  //false       //字符串比较        boolean equals = n.equals(name);        System.out.println(&quot;equals:&quot;+equals);   //true        boolean equal = n.equals(names);        System.out.println(&quot;equal:&quot;+equal);   //true        //字符串忽略大小写比较        String s = new String(&quot;Abc&quot;);        String s1 = &quot;abc&quot;;        boolean b = s.equalsIgnoreCase(s1);        System.out.println(b);   //true</code></pre></li><li><p>Boolean equals 方法（要比较的字符串）                  完全一样结果是true，否则为false</p></li><li><p>Boolean equalslgnoreCase（要比较的字符串）       忽略大小写的比较</p></li></ul></li></ul></li><li><p>StringBuilder</p><ul><li><p>可以看成是一个容器，创建之后内容是可以改变的</p></li><li><p>StringBuilder常用方法</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220907231629383.png" alt="image-20220907231629383"></p></li><li><p>使用StringBuilder的场景</p><ul><li>字符串拼接</li><li>字符串的反转</li></ul></li></ul></li><li><p>StringJoiner</p><ul><li>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的</li><li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用</li><li>JDK8才出现的</li></ul></li><li><p>字符串原理</p><ul><li>&#x3D;&#x3D;号比较的到底是什么？<ul><li>基本数据类型比较数组值</li><li>引用数据类型比较地址值</li></ul></li></ul></li><li><p>字符串拼接的底层原理</p><ul><li>如果很多字符串变量拼接，不要直接+。在底层会创建多个对象，浪费时间，浪费性能。</li><li>如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串</li><li>如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存</li></ul></li><li><p>StringBuilder底层原理</p><ul><li>所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存</li></ul></li><li><p>ArrayList集合</p><ul><li>长度可以变</li><li>集合不能直接存储基本数据类型</li></ul></li><li><p>static（静态）</p><ul><li>static表示静态，是java中的修饰符，可以修饰成员方法，成员变量</li><li>被static修饰的成员变量，叫做静态变量<ul><li>特点：<ul><li>被该类所有对象共享</li><li>不属于对象，属于类</li><li>随着类的加载而加载，优先于对象存在</li></ul></li><li>调用方法：<ul><li>类名调用</li><li>对象名调用</li></ul></li></ul></li><li>被static修饰的成员方法，叫做静态方法<ul><li><p>特点</p><ul><li>多用在测试类和工具类</li><li>javabean类中很少会用</li></ul></li><li><p>调用方法</p><ul><li>类名调用</li><li>对象名调用</li></ul></li></ul></li><li>工具类<ul><li>类名见名之义</li><li>私有化构造方法</li><li>方法都定义为静态方法，方便调用</li></ul></li><li>static的注意事项<ul><li>静态方法只能访问静态变量和静态方法</li><li>非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和静态的成员方法</li><li>静态方法中是没有this关键字</li></ul></li><li>总结：<ul><li>静态方法中，只能访问静态。</li><li>非静态方法可以访问所有。</li><li>静态方法中没有this关键字</li></ul></li></ul></li></ul></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li><p>java中提供一个关键字extedns</p></li><li><p>当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码</p></li><li><p>什么是继承、继承的好处？</p><ul><li>继承是面向对象的三大特征之一，可以让类跟类之间产生子父的关系</li><li>可以把多个子类中重复的代码抽取到父类中，子类可以使用，减少代码冗余，提高代码的复用性</li></ul></li><li><p>继承的格式？</p><ul><li>public class 子类 extedns 父类 {}</li></ul></li><li><p>继承后子类的特点？</p><ul><li>子类可以得到父类的属性和行为，子类可以使用。</li><li>子类可以在父类的基础上新增其他功能子类更强大</li></ul></li><li><p>子类到底能继承父类中的哪些内容？（内存图&#x2F;内存分析工具）</p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220911173759076.png" alt="image-20220911173759076" style="zoom:50%;" /></li><li><p>继承的特点</p><ul><li>java只支持单继承，不支持多继承，但支持多层继承。<ul><li>一个子类只能继承一个父类，子类不能同时继承多个父类，子类A继承父类B，父类B可以继承父类C。</li></ul></li></ul></li><li><p>继承中：成员变量的访问特点</p><ul><li><p>就近原则：谁离我近，我就用随</p><ul><li>先在局部位置找，本类成员位置找，父类成员位置找，逐级往上</li></ul></li><li><p>如歌出现了重名的成员变量怎么办吗？</p><pre><code class="java">System.out.println(name);System.out.println(this.name); System.out.println(super.name); //去找父类的name</code></pre></li></ul></li><li><p>继承中：成员方法的访问特点</p></li><li><p>继承中：构造方法的访问特点</p><ul><li>父类中的构造方法不会被子类继承，但是可以通过super来调用</li><li>子类构造方法的第一行，有一个默认的super();</li><li>默认先访问父类中无参的构造方法，在执行自己</li><li>如果想要方法文父类有参构造方法，必须手动书写。</li><li>子类中所有的构造方法默认先访问父类中的无参构造，在执行自己</li></ul></li></ul><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul><li>方法的重写<ul><li>当父类的方法不能满足子类现在的需求时，需要进行方法的重写</li><li>重写方法的名称、形参列表必须与父类一致</li><li>子类重写父类方法时，访问权限子类必须大于等于父类（暂时了解：空着不写&lt;protected&lt;public)</li><li>子类重写父类的方法时，返回值类型子类必须小于父类</li><li>只有被添加到虚方法表中的方法才能被重写</li></ul></li><li>书写格式<ul><li>在继承体系中，子类出现了和父类中一模一样的方法声明，我们称子类这个方法是重写的方法</li></ul></li><li>@Override重写的注解<ul><li>@Override是放在重写后的方法上，校验子类重写是语法是否正确</li><li>加上注解后如果有红色波浪线，表示语法错误</li><li>建议重写方法都加上@Override注解，代码安全，优雅</li></ul></li></ul><h4 id="this，super"><a href="#this，super" class="headerlink" title="this，super()"></a>this，super()</h4><ul><li>this:理解为一个变量，表示当前方法调用者的地址值；</li><li>super:代表父类存储空间。</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220912094526173.png" alt="image-20220912094526173">多态</h4><ul><li><p>​什么是多态？</p><ul><li>同类型的对象，表现出的不同的形态</li></ul></li><li><p>​多态的表现形式</p><ul><li>父类类型 对象名称 &#x3D; 子类对象；</li></ul></li><li><p>多态的前提</p><ul><li>有继承关系</li><li>有父类引用指向子类对象</li><li>有方法重写</li></ul></li><li><p>多态的好处？</p><ul><li>使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利</li></ul></li><li><p>多态调用成员的特点</p><ul><li>变量调用:编译看左边，运行看右边。</li><li>方法调用：编译看左边，运行看右边。</li></ul></li><li><p>多态的优势</p><ul><li>方法中，使用父类型作为参数，可以接受所有子类对象</li></ul></li><li><p>多态的弊端是什么？</p><ul><li>不能使用子类的特有功能</li></ul></li><li><p>引用数据类型的类型转换，有几种方式？</p><ul><li>自动类型转换，强制类型转换</li></ul></li><li><p>强制类型转换能解决什么问题？</p><ul><li>可以转换成真正的子类型类型，从而调用子类独有功能</li><li>转换类型与真实对象类型不一致会报错</li><li>转换的时候用instanceof关键字进行判断</li></ul></li></ul><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>​使用final修饰之后是不能改变的</p><ul><li>方法 表面该方法最终方法，不能被重写</li><li>类instanceof表面该类是最终类，不能被继承</li><li>变量 叫做常量，只能被赋值一次</li><li>final修饰变量：是常量，不能修改<ul><li>基本数据类型：变量的值不能修改</li><li>引用数据类型：地址值不能修改但是内部的属性值可以修改</li></ul></li></ul><p>使用场景</p><ul><li>​一些系统不可被修改的常量</li></ul><h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><ul><li><p>private ： 私有的，只能 自己用</p></li><li><p>默认 ： 只能在本包里面用</p></li><li><p>protected ： 受保护的</p></li><li><p>public ： 公共的</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220912153212668.png" alt="image-20220912153212668"></p></li></ul><ol><li>构造代码块<ol><li>写在成员位置的代码块</li><li>作用：可以把多个构造方法中重复的代码抽取出来</li><li>执行时机：我们在创建本类对象的时候会执行构造代码块再执行构造方法</li></ol></li><li>静态代码块<ol><li>格式：static{}</li><li>数据的初始化（重点）</li><li>执行时机：随着类的加载而加载的，并且只执行一次</li></ol></li></ol><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul><li>抽象类<ul><li>public abstract class 类名{}</li><li>如果一个<u>类中存在抽象方法</u>，那么这个类就<u>必须声明为抽象类</u></li></ul></li><li>抽象方法<ul><li>格式:public abstract 返回值类型 方法名（参数列表）；</li><li>抽象方法：将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容不一样，所以，再父类中不能确定具体的方法体。该方法就可以定义为抽象方法。</li></ul></li><li>子类继承抽象类之后，如何重写抽象方法</li><li>抽象类和抽象方法注意事项<ul><li>抽象类不能实例化（抽象类不能创建对象）</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>可以有构造方法</li><li>抽象的子类<ul><li>要么重写抽象类中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul></li><li>抽象类的作用是声明样的？<ul><li>抽取共性时，无法确定方法体，就把方法定义为抽象的，强制让子类按照某种格式重写。</li></ul></li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li>接口：就是一种规则</li><li>接口的定义和使用<ul><li>接口用关键字interface来定义<ul><li>public interface 接口名{}</li></ul></li><li>接口不能实例化</li><li>接口和类之间是实现关系，通过implements关键字表示<ul><li>public class 类名implement 接口名 {}</li></ul></li><li>接口的子类（实现类）<ul><li>要么重写接口中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul></li><li>接口成员的特点<ul><li>成员变量<ul><li>只能是常量</li><li>默认修饰符：public static final</li></ul></li><li>没有构造方法</li><li>成员方法<ul><li>只能是抽象方法</li><li>默认修饰符：public abstract</li></ul></li><li>jdk7以前：接口只能定义抽象方法</li></ul></li><li>接口和类之间的关系<ul><li>类和类之间的关系<ul><li>继承关系，只能单继承，不能多继承，但是可以多层继承</li></ul></li><li>类和接口的关系<ul><li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li></ul></li><li>接口和接口的关系<ul><li>继承关系，可以单继承，也可以多继承</li></ul></li></ul></li></ul><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul><li><p>类的五大成员：</p><ul><li>属性，方法，构造方法、代码块、内部类</li></ul></li><li><p>内部类的分类</p><ul><li><p>成员内部类</p><ul><li><p>写在成员位置，属于外部类的一员</p></li><li><p>成员内部类可以被修饰符所修饰</p></li><li><p>在成员内部类里面，JDK16之前不能定义静态变量，JDK16才开始可以定义静态变量</p></li><li><p>调用格式</p><pre><code>package Day;public class Day06Test &#123;    public static void main(String[] args) &#123;        //        创建内部类对象        Day06.Engine  e= new Day06().new Engine();        e.show();        //创建内部类对象,在外部类创建一个成员方法来调用内部类的对象        Day06 d = new Day06();        Day06.Engine engine = d.getEngine();        engine.show();    &#125;&#125;</code></pre></li></ul></li><li><p>静态内部类</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220914224011897.png" alt="image-20220914224011897"></p></li><li><p>局部内部类</p><ul><li>将内部类定义在方法里面就叫做局部内部类，类似于方法的局部变量</li><li>外界是无法直接使用，需要在方法内部创建对象并使用</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li></ul></li><li><p>匿名内部类</p><ul><li>内部类本质上就是隐藏了名字的内部类</li><li>定义格式</li></ul><pre><code>new 类名或者接口名()&#123;      //如歌类名是类那么就是继承关系，如果是接口名那么就是实现接口    重写方法;&#125;;</code></pre></li></ul></li><li><p>什么是内部类</p><ul><li>在一个类中，再定义一个类</li></ul></li><li><p>内部类的访问特点</p><ul><li><p>内部类可以直接访问外部类的成员，包括私有</p></li><li><p>外部类要访问内部类的成员，必须创建对象</p><pre><code>package Day;public class Day06 &#123;    String carName;    int carAGe;    String carColor;     int a = 30;    //定义一个外部类的方法    public  void  shows()&#123;        //外部类访问成员变量        System.out.println(carAGe);        //外部类访问不了内部类的成员变量//        System.out.println(engineAgge);        //外部类访问不了内部类的成员方法//        show();    &#125;    //定义一个内部类    class Engine&#123;        String engineName;        int engineAgge;        int a = 10;        //定义一个内部类的方法        public void show()&#123;             int a = 20;            //内部类访问内部类的成员变量            System.out.println(engineName);            //内部类访问外部类的成员变量            System.out.println(carName);            //内部类访问外部类的成员方法            shows();            //如果内部类和外部类的成员变量同名需要以下方法调用             System.out.println(a);//20             System.out.println(this.a);  //10             System.out.println(Day06.this.a);//30        &#125;    &#125;&#125;</code></pre></li></ul></li></ul><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><pre><code>package math;public class MathTest &#123;    public static void main(String[] args) &#123;        float a = 314554.88f;        int round = Math.round(a);        System.out.println(round);        //返回绝对值        int b = -100;        int abs = Math.abs(b);        System.out.println(abs);        //返回两个数的总数 如果数据超出int范围会抛出异常        int x = 2, y = 10;        int i = Math.addExact(x, y);        System.out.println(i);        //返回乘数的乘积        //比较两个数的最大值        int maxA= 10,maxB=20;        int max = Math.max(maxA, maxB);        System.out.println(max);        //比较两个数的最小值        int minA=50,minB=60;        int min = Math.min(minA, minB);        System.out.println(min);        //返回两个数的相乘        int i1 = Math.multiplyExact(x, y);        System.out.println(i1);        //向上取整        System.out.println(Math.ceil(20.85));//21.0        //向下取整        System.out.println(Math.floor(20.85));//20.0        //代表2的三次方，如果第二个参数是0~1之间的小数        System.out.println(Math.pow(2, 3)); //8.0        System.out.println(Math.pow(2, 0.5)); //1.4142135623730951        //代表开根号        System.out.println(Math.sqrt(98)); //2.0        //开立方根        System.out.println(Math.cbrt(8));//2.0    &#125;&#125;</code></pre><h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220918172005955.png" alt="image-20220918172005955" style="zoom:67%;" /><pre><code>package math;public class SystemTest &#123;    public static void main(String[] args) &#123;        //0:表示当前虚拟机是正常停止        //非0，表示当前虚拟机异常停止//        System.exit(0);        long l = System.currentTimeMillis();        System.out.println(l);        //拷贝数组        int[] arr1 = &#123;1,2,3,4,5,6,7,8,9,10&#125;;        int[] arr2 = new int[10];        //第一个参数：数据源，要拷贝的数据        //第二个参数：从数据源哪个索引开始拷贝        //第三个参数：新数组        //第四个参数：拷贝到新数组的哪个位置        //第五个参数：拷贝多少个数据//        System.arraycopy(arr1,3,arr2,0,7);        //课堂练习 arr2 : 0 0 0 0 1 2 3 0 0 0        System.arraycopy(arr1,0,arr2,4,3);        for (int i = 0; i &lt; arr2.length; i++) &#123;            System.out.print(arr2[i]+&quot; &quot;);        &#125;    &#125;&#125;</code></pre><h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><ul><li><p>Runtime表示当前虚拟机的运行环境</p><pre><code>package math;import java.io.IOException;public class RuntimeTest &#123;    public static void main(String[] args) &#123;        Runtime runtime = Runtime.getRuntime();        System.out.println(runtime);        int i = runtime.availableProcessors();    //获取CPU的线程数        System.out.println(i);//12        long l = runtime.maxMemory();   //JVM能从系统中获取总内存大小(单位byte)        System.out.println(l);        long l1 = runtime.totalMemory();   //JVM已经从系统中获取总内存大小(单位byte)        System.out.println(l1);        long l2 = runtime.freeMemory();   //获取jvm剩余多少内存可以使用        System.out.println(l2);        try &#123;           runtime.exec(&quot;notepad&quot;); //运行cmd命令 notepad打开记事本        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul><li><p>Object是java中定级父类。所有类都直接或间接的继承于Object类</p></li><li><p>Object类中的方法可以被所有子类访问。</p></li><li><p>Object方法</p><ul><li>toString</li><li>equals</li><li>clone()&#96; 对象克隆<ul><li>方法在底层会帮我们创建一个对象，并把原对象中的数据拷贝过去</li><li>重写Object中的clone方法</li><li>让JavaBean类实现Cloneable接口</li><li>创建元对象并调用clone就可以了</li><li>浅克隆</li><li>深克隆<ul><li>以下的代码深克隆还是有弊端，因为以后是个二维数组又要修改，所以会使用第三方写的代码Gson</li></ul></li></ul></li></ul><pre><code>package math;import java.util.Arrays;import java.util.Objects;public class Student implements Cloneable &#123;    private String name;    private int  age;    private int[] arr;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public int[] getArr() &#123;        return arr;    &#125;    public void setArr(int[] arr) &#123;        this.arr = arr;    &#125;    public Student(String name, int age, int[] arr) &#123;        this.name = name;        this.age = age;        this.arr = arr;    &#125;    public Student() &#123;    &#125;    //重写object中的toString    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, arr=&quot; + Arrays.toString(arr) +                &#39;&#125;&#39;;    &#125;    //重写object中的equals    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Student student = (Student) o;        return age == student.age &amp;&amp; Objects.equals(name, student.name) &amp;&amp; Arrays.equals(arr, student.arr);    &#125;    //重写object中的clone    @Override    protected Object clone() throws CloneNotSupportedException &#123;        //如果想深克隆,不加这个就是浅克隆。浅克隆如果是引用类型那么复制的是地址值，如果成员属性中有数组，那么复制的是地址值，        // 如果其中一个修改数组中的元素就会跟着修改，所以定义深克隆        int[] data = this.arr;        //创建新数组，将旧数组里面的数据直接拷贝的新数组里面        int[]  newData = new int[data.length];        for (int i = 0; i &lt; data.length; i++) &#123;            newData[i] = data[i];        &#125;       //直接调用父类中的方法克隆对象        Student s = (Student) super.clone();        s.arr = newData;        return s;    &#125;    /**     * 浅克隆     *///    @Override//    protected Object clone() throws CloneNotSupportedException &#123;//        return super.clone();//    &#125;&#125;</code></pre><pre><code>package math;public class ObjectTest &#123;    public static void main(String[] args) throws CloneNotSupportedException &#123;        int[] data= &#123;1,2,3,4,5,6,7,8,9,10&#125;;        Student s = new Student(&quot;蔡&quot;,20,data);        System.out.println(s);   //Student&#123;name=&#39;蔡&#39;, age=20, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;  在javaBean中重写toString就可以这样显示        System.out.println(s);    //math.Student@1b6d3586    如果没有重写toString方法就会打印出地址值，会使用Object的toString        Student s1 = new Student();        Student s2 = new Student();        boolean result = s1.equals(s2);        System.out.println(result);   //false  如果在javaBean中不重写equals方法就会比较两个对象的地址值两个地址值是new出来的所以在内存堆中,会使用Object的equals        System.out.println(result);   //true  如果在javaBean中重写equals方法就会使用javaBean中重写的equals方法。        //直接调用javabean类中重写的克隆方法        Student s4 = (Student) s.clone();        //修改拷贝后数组的第一个元素的数据        int[] arr = s4.getArr();        arr[0] = 55;        System.out.println(s4);  //Student&#123;name=&#39;蔡&#39;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;        System.out.println(s);  //原数组的数组第一个数据也被修改了Student&#123;name=&#39;蔡&#39;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;        //在javabean中重写了浅克隆，变成了深克隆        System.out.println(s4);  //Student&#123;name=&#39;蔡&#39;, age=20, arr=[55, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;        System.out.println(s);   //Student&#123;name=&#39;蔡&#39;, age=20, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;    &#125;&#125;</code></pre></li></ul><h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><ul><li><p>BigInteger构造方法</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220919214226833.png" alt="image-20220919214226833"></p></li></ul><h4 id="BigDecima"><a href="#BigDecima" class="headerlink" title="BigDecima"></a>BigDecima</h4><ul><li><p>用于小数的精确计算</p></li><li><p>用来表示很大的小数</p><pre><code>package math;import java.math.BigDecimal;public class BigDecimalTest &#123;    public static void main(String[] args) &#123;        //使用double形参构造函数会数据不精确        BigDecimal b = new BigDecimal(0.01);        BigDecimal bg = new BigDecimal(0.09);        BigDecimal bg1 = b.add(bg);        System.out.println(b);  //0.01000000000000000020816681711721685132943093776702880859375        System.out.println(bg);//0.0899999999999999966693309261245303787291049957275390625        System.out.println(bg1);//0.09999999999999999687749774324174723005853593349456787109375        //使用String形参构造函数数据精确        BigDecimal b1 = new BigDecimal(&quot;0.01&quot;);        BigDecimal b2 = new BigDecimal(&quot;0.09&quot;);        //add b1加上b2        BigDecimal b3 = b1.add(b2);        System.out.println(b1);  //0.01        System.out.println(b2);//0.09        System.out.println(b3);//0.10    &#125;&#125;</code></pre></li></ul><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul><li><p>作用</p><ul><li><p>检验字符串是否满足规则</p></li><li><p>在一段文本中查找满足要求的内容</p></li><li><p>正则表达式字符的基本操作</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220923130744244.png" alt="image-20220923130744244"></p></li></ul><pre><code>package Day.Api.zhengze;public class Test &#123;    public static void main(String[] args) &#123;        //判断一个是不是qq号        String qq = &quot;1311871826&quot;;        //[1-9]这个代表上面第一个数字不能以0开头  \\d代表数字 &#123;4,9&#125;这个代表除了第一个数字后面的数必须是4~9位数字要不然就是返回false        System.out.println(qq.matches(&quot;[1-9]\\d&#123;4,9&#125;&quot;));        System.out.println(&quot;-------------------------&quot;);        System.out.println(&quot;a&quot;.matches(&quot;[abc]&quot;));  //true        System.out.println(&quot;z&quot;.matches(&quot;[abc]&quot;));  //false        System.out.println(&quot;ab&quot;.matches(&quot;[abc]&quot;)); //false  因为这样[abc]只能匹配字符串一个字符所以false所以要改成[abc][abc]这个就是true        System.out.println(&quot;-------------------------&quot;);        //[^abc]  ^取反的意思        System.out.println(&quot;a&quot;.matches(&quot;[^abc]&quot;));  //false        System.out.println(&quot;z&quot;.matches(&quot;[^abc]&quot;));  //true        System.out.println(&quot;zz&quot;.matches(&quot;[^abc]&quot;));  //false        System.out.println(&quot;zz&quot;.matches(&quot;[^abc][^abc]&quot;));//true        System.out.println(&quot;---------------------------&quot;);        //[a-zA-Z]可以是a-z的大写和小写        System.out.println(&quot;a&quot;.matches(&quot;[a-zA-Z]&quot;)); //true        System.out.println(&quot;Z&quot;.matches(&quot;[a-zA-Z]&quot;)); //true        System.out.println(&quot;aa&quot;.matches(&quot;[a-zA-Z]&quot;));//false    //[a-zA-Z][a-zA-Z] true        System.out.println(&quot;zz&quot;.matches(&quot;[a-zA-Z]&quot;));//false        System.out.println(&quot;0&quot;.matches(&quot;[a-zA-Z]&quot;));//false    //[a-zA-Z0-9] false  //[0-9] true        System.out.println(&quot;----------------------&quot;);        //[a-d[m-p]] a到d，或m到p        System.out.println(&quot;a&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true        System.out.println(&quot;d&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true        System.out.println(&quot;m&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true        System.out.println(&quot;p&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true        System.out.println(&quot;e&quot;.matches(&quot;[a-d[m-p]]&quot;)); //false   //e不在范围内所以是false        System.out.println(&quot;0&quot;.matches(&quot;[a-d[m-p]]&quot;)); //false  //0是数字正则匹配里面没有数字        System.out.println(&quot;--------------------------&quot;);        //[a-z&amp;&amp;[def]]        //其实就是它们的交集  def        System.out.println(&quot;d&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //true        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //false        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //false        //[a-z&amp;&amp;[^bc]]  除了bc字母都可以        System.out.println(&quot;-------------------&quot;);        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //true        System.out.println(&quot;b&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //false        System.out.println(&quot;z&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));  //true        System.out.println(&quot;z&quot;.matches(&quot;[a-z&amp;[^bc]]&quot;));  //true 因为&amp;只能当当是符号不是&amp;&amp;这个才是且        System.out.println(&quot;-------------------------&quot;);        //[a-z&amp;&amp;[^m-p]]  除了m-p中的字母，其它字母都可以        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //true        System.out.println(&quot;m&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //false        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //false  &#125;&#125;</code></pre></li></ul><h4 id="jDK7前时间类"><a href="#jDK7前时间类" class="headerlink" title="jDK7前时间类"></a>jDK7前时间类</h4><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220924144225531.png" alt="image-20220924144225531"></p><ul><li><p>Date  时间</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220924150106666.png" alt="image-20220924150106666"></p></li><li><p>SimpleDateFormat 格式化时间</p><ul><li>作用<ul><li>格式化：把时间变成自己的格式</li><li>解析：把字符串表示的时间变成Date</li></ul></li></ul><pre><code>package Day.Api.date;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest &#123;    public static void main(String[] args) throws ParseException &#123;            //时间原点        Date date1 = new Date(0L);        System.out.println(date1); //Thu Jan 01 08:00:00 CST 1970            Date date = new Date();        System.out.println(date);        //格式化时间YYYY年MM月dd日 HH:mm:ss E        SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss E&quot;);        String format = s.format(date);        System.out.println(format);  //2022年09月24日 15:23:32 星期六        //解析时间        String d = &quot;2022-09-24 15-26-20&quot;;        SimpleDateFormat sp = new SimpleDateFormat(&quot;yyyy-MM-dd HH-mm-ss&quot;);        Date parse = sp.parse(d);        System.out.println(parse); //Sat Sep 24 15:26:20 CST 2022    &#125;&#125;</code></pre></li><li><p>Calendar 日历</p><pre><code>package Day.Api.date;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class DateTest &#123;    public static void main(String[] args) throws ParseException &#123;       //Calendar 是一个抽象类，不能直接new        Calendar c = Calendar.getInstance();        int year = c.get(Calendar.YEAR);        int moth = c.get(Calendar.MONTH) + 1;        int dt = c.get(Calendar.DATE);        int week = c.get(Calendar.DAY_OF_WEEK);  // 1(星期日) 2(星期一) 3(星期二) 4(星期三) 5(星期四) 6(星期五) 7(星期六)        System.out.println(year+&quot;年&quot;+moth+&quot;月&quot;+dt+&quot;日&quot;+&quot; &quot;+week(week)); //2022年9月24日        //修改年为2023年        c.set(Calendar.YEAR,2023);        System.out.println(c.get(Calendar.YEAR));        //如果想修改月份为12月，那么修改值要填11，因为Calendar的月份是少1的        c.set(Calendar.MONTH,11);        System.out.println(c.get(Calendar.MONTH));    &#125;    //定义一个方法传入外国人对星期几的数字转换成中文    public static String week(int week)&#123;        String[] wek = &#123;&quot;&quot;,&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;&#125;;        return wek[week];    &#125;&#125;</code></pre></li></ul><h4 id="jdk8时间类"><a href="#jdk8时间类" class="headerlink" title="jdk8时间类"></a>jdk8时间类</h4><ul><li>为什么要学jdk8新增时间相关类<ul><li>代码层面<ul><li>jdk：代码麻烦 </li><li>jdk8：简单<ul><li>判断的方法</li><li>计算时间间隔的方法</li></ul></li></ul></li><li>安全层面<ul><li>jdk：多线程环境下会导致数据安全的问题</li><li>jdk8：时间日期对象都是不可变的，解决了这个问题</li></ul></li></ul></li></ul><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220924165212609.png" alt="image-20220924165212609"></p><ul><li><p>时区，时间戳，带时区的时间，格式化和解析时间</p><pre><code>package Day.Api.date;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Set;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/9/24 * Time: 16:37 * 需求： */public class DateTest01 &#123;    public static void main(String[] args) &#123;        //ZoneId        //获取java中所有支持时区        Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();        System.out.println(availableZoneIds);        //获取电脑时区        ZoneId zoneId = ZoneId.systemDefault();        System.out.println(zoneId); //Asia/Shanghai        //设置指定的时区        ZoneId of = ZoneId.of(&quot;Asia/Aden&quot;);        System.out.println(of);        System.out.println(&quot;---------Instant--------------&quot;);        //获取的世界标准时间对象，如果想获取当前时间小时需要加8个小时        Instant now = Instant.now();        System.out.println(now);        /**         * 根据（秒/毫秒/纳秒）获取Instant对象         */        //根据纳秒获取        Instant instant1 = Instant.ofEpochMilli(0L);        System.out.println(instant1);//1970-01-01T00:00:00Z        //根据秒        Instant instant2 = Instant.ofEpochSecond(1);        System.out.println(instant2);//1970-01-01T00:00:01Z 根据时间原点加一秒        //第一个参数根据秒 ，第二个参数根据纳秒        Instant instant3 = Instant.ofEpochSecond(1L, 1000000000L);        System.out.println(instant3);//1970-01-01T00:00:02Z        //指定地区的时间点        ZonedDateTime zonedDateTime = now.atZone(ZoneId.of(&quot;Asia/Shanghai&quot;));        System.out.println(zonedDateTime);//2022-09-25T18:40:57.110030600+08:00[Asia/Shanghai]        System.out.println(&quot;----------ZonedDateTime-----------&quot;);        //获取当前时区时间的对象        ZonedDateTime now1 = ZonedDateTime.now();        System.out.println(now1);//2022-09-25T18:46:16.151643500+08:00[Asia/Shanghai]        System.out.println(&quot;-----------------DateTimeFormatter---------------&quot;);        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);        String format = dateTimeFormatter.format(now1);        System.out.println(format);    &#125;&#125;</code></pre></li></ul><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><ul><li>什么是包装类<ul><li>基本数据类型对应的对象</li></ul></li><li>JDK5新增的特性<ul><li>自动装箱</li><li>自动拆箱</li></ul></li><li>各个基本类型的包装类</li></ul><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20220929215914294.png" alt="image-20220929215914294"></p><p>​</p><pre><code>package Day.packaging;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/9/29 * Time: 21:56 * 需求： */public class TestInteger &#123;    public static void main(String[] args) &#123;        //包装类，数字引用数字类型 Jdk5写法        //利用构造方法来创建对象        System.out.println(&quot;----------构造法创建对象---------------&quot;);        Integer a = new Integer(10);        Integer a1 = new Integer(&quot;10&quot;);        System.out.println(a);        System.out.println(a1);        System.out.println(&quot;--------------静态方法创建对象------------------&quot;);        //利用静态方法创建对象        Integer in = Integer.valueOf(10);        Integer integer = Integer.valueOf(&quot;123&quot;);        Integer integer1 = Integer.valueOf(&quot;123&quot;, 8);        System.out.println(in);        System.out.println(integer);        System.out.println(&quot;输出8进制的数:&quot;+integer1);        Integer c=10;        System.out.println(c);        //两个创建的对象区别        //这个判断的是数字如果数字不在-128~127那么源码中会new出来的所以超过127就是判断地址值        Integer i5 = Integer.valueOf(127);        Integer i6 = Integer.valueOf(127);        System.out.println(i5==i6);  //true        Integer i7 = Integer.valueOf(128);        Integer i8 = Integer.valueOf(128);        System.out.println(i7==i8);  //false        //底下这种判断的是地址值所以是false        Integer i1 = new Integer(127);        Integer i2 = new Integer(127);        System.out.println(i1==i2);//false        Integer i3 = new Integer(128);        Integer i4 = new Integer(128);        System.out.println(i3==i4);//false    &#125;&#125;</code></pre><h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><ul><li><p>查找算法</p><ul><li><p>基本查找    </p><ul><li><p>基本查找的实现</p><pre><code>package find;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/9/30 * Time: 12:52 * 需求：查找算法 */public class BasicSearch &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;20,30,40,60,70,90,100,120,150&#125;;        //基本查找        boolean b = basicSearch(arr, 20);        System.out.println(b);    &#125;    //基本查找    public static boolean basicSearch(int Array[],int number)&#123;        for (int i = 0; i &lt; Array.length; i++) &#123;            if (Array[i]==number)&#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;</code></pre></li></ul></li><li><p>二分查找&#x2F;折半查找</p><ul><li><p>二分查找前提条件是数组的数据是顺序的</p></li><li><p>提高查找效率</p></li><li><p>二分查找过程</p><ul><li>min和max表示当前要查找的范围</li><li>中间是在min和max中间的</li><li>如果要查找的元素在mid的左边，缩小范围时，min不变， max等于mid减1</li><li>如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1</li></ul></li><li><p>二分查找的代码实现</p><ul><li><pre><code>package find;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/9/30 * Time: 12:52 * 需求：查找算法 */public class BasicSearch &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;20,30,40,60,70,90,100,120,150&#125;;        int i = ErBasicSearch(arr, 30);        System.out.println(i);    &#125;    //二分查找    /**     *     * @param Array     * @param number     * @return     * 1, min和max表示当前要查找的范围     * 2，中间是在min和max中间的     * 3,如果要查找的元素在mid的左边，缩小范围时，min不变， max等于mid减1     * 4,如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1     */    public static int ErBasicSearch(int Array[],int number)&#123;        int max =   Array.length-1;        int min = 0;        while (true)&#123;            int mid = (max+min)/2;            if (min&gt;max)&#123;                return -1;            &#125;            if (Array[mid]&gt;number)&#123;                max=mid-1;            &#125;else if (Array[mid]&lt;number)&#123;                min = mid+1;            &#125;else  &#123;                return mid;            &#125;        &#125;    &#125;&#125;</code></pre></li></ul></li></ul></li></ul></li></ul><h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><ul><li><p>常用方法</p><ul><li><pre><code>package Day.Api.Arrays;import java.util.Arrays;import java.util.Collection;import java.util.Comparator;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/2 * Time: 16:42 * 需求： */public class MyArrayTest01 &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;        System.out.println(&quot;--------Arrays toString----------------&quot;);        //返回指定数组内容的字符串表示形式        System.out.println(Arrays.toString(arr));  //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        //使用二分查找查找元素        //第一:二分查找的数组中的元素是有序的，而且是升序的        //第二：如果查找的数据存在返回索引        System.out.println(&quot;--------Arrays binarySearch----------------&quot;);        System.out.println(Arrays.binarySearch(arr, 5));//4        System.out.println(Arrays.binarySearch(arr, 10));//9        System.out.println(Arrays.binarySearch(arr, 20));//-11        //复制新数组        //第一个参数是旧数组的数据        //第二个参数是，要从数组中的复制多少个数据到新数组，如果新数组的长度大于旧数组的长度，那么后面的数据用数组的初始值        System.out.println(&quot;--------Arrays copyOf----------------&quot;);        int[] ints = Arrays.copyOf(arr, 20);        System.out.println(Arrays.toString(ints));        //排序        System.out.println(&quot;--------Arrays sort  升序----------------&quot;);        Integer[] array = &#123;20, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;;//        Arrays.sort(array);//        System.out.println(Arrays.toString(array));        //降序排序o2-o1        //升序排序o1-o2        Arrays.sort(array,new Comparator&lt;Integer&gt;()&#123;            @Override            public int compare(Integer o1, Integer o2) &#123;                return o2-o1;            &#125;        &#125;);        System.out.println(Arrays.toString(array));    &#125;&#125;</code></pre></li></ul></li></ul><h4 id="lambda-JDK8"><a href="#lambda-JDK8" class="headerlink" title="lambda  JDK8"></a>lambda  JDK8</h4><ul><li>注意事项<ul><li>Lambda表达式可以用来简化匿名内部类的书写</li><li>Lambda表达式只能简化函数式接口的匿名内部类的写法</li><li>函数式接口：<ul><li>有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解</li></ul></li></ul></li></ul><pre><code>package Day.Api.Arrays;import java.util.Arrays;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/2 * Time: 17:22 * 需求： */public class LambdaTest &#123;    public static void main(String[] args) &#123;        Integer[] array = &#123;20, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;;        //降序排序        // lambda表达式 -&gt;//        Arrays.sort(array, (Integer o1, Integer o2) -&gt; &#123;//                    return o2 - o1;//                &#125;//        );        //Integer如果数据类型相同们可以省略//        Arrays.sort(array, (o1,  o2) -&gt; &#123;//                    return o2 - o1;//                &#125;//        );        //也可以省略花括号和return        Arrays.sort(array, (o1,  o2) -&gt;o2 - o1);        System.out.println(Arrays.toString(array));    &#125;&#125;</code></pre><h4 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h4><ul><li><p>Collection：是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的</p><ul><li>遍历方式<ul><li>迭代器遍历</li><li>增强for遍历</li><li>Lambda表达式遍历</li></ul></li></ul></li><li><p>List</p><ul><li>添加的元素是有序的、可重复、有索引</li></ul></li><li><p>Set</p><ul><li>添加的元素是无序、不重复、五索引</li></ul></li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li>迭代器遍历<ul><li>迭代器在java中类是Iterator，迭代器是集合专用的遍历方式。</li></ul></li><li>Collection集合获取迭代器</li><li>注意事项<ul><li>报错NoSuchElementException</li><li>迭代器遍历完毕，指针不会复位</li><li>迭代器遍历时，不能用集合的方法进行增强或者删除</li></ul></li></ul><pre><code>package Day;import java.util.ArrayList;import java.util.Iterator;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/3 * Time: 16:56 * 需求：迭代器遍历 */public class Day186 &#123;    public static void main(String[] args) &#123;        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;aaa&quot;);        list.add(&quot;bbb&quot;);        list.add(&quot;ccc&quot;);        Iterator&lt;String&gt; it = list.iterator();        //查看集合指针位置是否有元素，如果有数就是true，没有就是false        while (it.hasNext())&#123;            //使用next方法获取第一个元素，并且移动指针到集合的第二个位置            String str = it.next();            System.out.println(str);        &#125;    &#125;&#125;</code></pre><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20221003172048287.png" alt="image-20221003172048287"></p><h4 id="集合遍历方式"><a href="#集合遍历方式" class="headerlink" title="集合遍历方式"></a>集合遍历方式</h4><pre><code>package Day;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.ListIterator;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/3 * Time: 18:49 * 需求：List 五种遍历 */public class Day188 &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list  = new ArrayList&lt;&gt;();        list.add(&quot;aaa&quot;);        list.add(&quot;bbb&quot;);        list.add(1,&quot;ccc&quot;);        System.out.println(list);        //迭代器遍历  如果想删除元素请用迭代器遍历        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext())&#123;            String str = it.next();            if (&quot;bbb&quot;.equals(str))&#123;                it.remove();            &#125;            System.out.println(str);        &#125;        System.out.println(list);        //列表迭代器遍历  如果想添加元素请用列表迭代器遍历        ListIterator&lt;String&gt; itList = list.listIterator();        while (itList.hasNext())&#123;            String str = itList.next();            if (&quot;aaa&quot;.equals(str))&#123;                itList.add(&quot;bbb&quot;);            &#125;            System.out.println(str);        &#125;        System.out.println(list);        //如果单纯遍历数据请用增强for或Lambda表达式遍历        for (String s : list) &#123;            System.out.print(s+&quot; &quot;);        &#125;        System.out.println();        list.forEach(s -&gt; System.out.print(s+&quot; &quot;));        System.out.println();        //如果想操作索引，使用普通for        for (int i = 0; i &lt; list.size(); i++) &#123;            System.out.print(list.get(i)+&quot; &quot;);        &#125;    &#125;&#125;</code></pre><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p>什么是数据结构</p><ul><li>计算机存储、组织数据的方式</li><li>是指数据相互之间是以什么方式排列在一起的</li><li>数据结构是为了更加方便的管理和使用数据，需要结合具体的业务场景来进行选择</li><li>一般情况下，精心选择数据结构可以带来跟高的运行或者存储效率</li></ul></li><li><p>常见的数据结构</p><ul><li><p>栈</p><ul><li><p>栈的特点：后进先出，先进后出</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20221003191448309.png" alt="image-20221003191448309"></p></li></ul></li><li><p>队列</p><ul><li><p>特点：先进先出，后进后出</p><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20221003191404657.png" alt="image-20221003191404657"></p></li></ul></li><li><p>数组</p><ul><li>特点：内存连续区域，查询快，增删慢</li></ul></li><li><p>链表</p><ul><li>特点：元素是游离的，查询慢，首尾操作极快</li></ul></li><li><p>二叉树</p><ul><li>二叉查找树遍历方式</li><li>前序遍历：当前节点，左子节点，右子节点<ul><li>中序遍历：左子节点，中子节点，右子节点</li><li>后序遍历：左子节点，右子节点，当前节点</li><li>层序遍历：一层一层的去遍历</li></ul></li></ul></li><li><p>二叉查找树平衡二叉树</p></li><li><p>红黑树</p><ul><li>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构</li><li>1972年出现，当时被称为平衡二叉B树。后来，1978年被修改为如今的“红黑叔”</li><li>它是一种特殊的二叉树查找树，红黑树的每一个节点上都有存储位表示节点的颜色</li><li>每一个节点可以是红或者黑，红黑树不是高度平衡的，它的平衡是通过“红黑规则”进行实现的</li><li>红黑树规则<ul><li>每一个节点或是红色的，或是黑色的</li><li>根节点必须是黑色的</li><li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点（Nil）是黑色的</li><li>如果某一个节点是红色，那么它的节点必须是黑色（不能出现两个红色节点相连的情况）</li><li>对每一个节点，从节点到其所有后代叶节点的简单路劲上，均包含相同的黑色节点</li></ul></li></ul></li></ul></li></ul><h4 id="ArrayList底层原理"><a href="#ArrayList底层原理" class="headerlink" title="ArrayList底层原理"></a>ArrayList底层原理</h4><ul><li>利用空参创建的集合，在底层创建一个默认长度为0的数组</li><li>添加一个元素时，底层会创建一个新的长度为10的数组</li><li>存满时，会扩容1.5倍</li><li>如果一次添加多个元素，1.5倍还放不下，则新床数组的长度以实际为准</li></ul><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ul><li><p>什么是泛型</p><ul><li>JDK5引入的特性，可以在编译阶段约束操作的数据类类型，并进行检查</li></ul></li><li><p>泛型好处</p><ul><li>统一数据类型</li><li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来</li></ul></li><li><p>泛型的细节</p><ul><li>泛型中不能写基本数据类型</li><li>指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型</li><li>如果不写泛型，类型默认是Object</li></ul></li><li><p>哪里可以定义泛型</p><ul><li>泛型类：在类名后定义泛型，创建该类对象的时候，确定类型</li><li>泛型方法：在修饰符后面定义泛型，调用方法的时候确定类型</li><li>泛型接口：在接口名后面定义泛型，实现类确定类型，实现类延续泛型</li></ul></li><li><p>泛型的继承和通配符</p><ul><li>泛型不具备继承性，但是数据具备继承性</li></ul></li></ul><h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><ul><li>无序：存取顺序不一致</li><li>不重复：可以去除重复</li><li>无索引：没有带索引的方法，所以不能使用普通for遍历，也不能通过索引来获取元素</li><li>set集合实现类<ul><li>HashSet：无序、不重复、无索引</li><li>LinkedHashSet：有序、不重复、无索引</li><li>TreeSet：可排序、不重复、五索引 <ul><li>TreeSet自定义排序规则有几种方式<ul><li>方法一：javabean类实现Comparable接口，指定比较规则</li><li>方法二：创建集合时，自定义Comparator比较对象，指定比较规则</li></ul></li></ul></li></ul></li></ul><h4 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h4><ul><li><p>特点</p><ul><li>双列集合一次需要存一对数据，分别为键和值</li><li>键不能重复，值可以重复</li><li>键和值是一一对应的，每一个键只能找到自己对应的值<ul><li>键+值这个整体我们称之为“键值对”或者“键值对对象”在java中叫做“Entry对象”</li></ul></li></ul><p></p></li><li><p>HashMap</p><ul><li><p>特点</p><ul><li>HashMap里面的一个实现类</li><li>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了</li><li>特点都是由键决定的：无序、不重复、无索引</li><li>HashMap跟HashSet底层原理一模一样的，都是哈希表结构</li></ul></li><li><p>HashMap基本方法</p><pre><code>  package Day.Api.map;    import java.util.HashMap;  import java.util.Map;    /**   * Created with IntelliJ IDEA.   * creator: 蔡芳灿   * Date: 2022/10/5   * Time: 21:17   * 需求：   */  public class MapTest &#123;      public static void main(String[] args) &#123;          Map&lt;String,String&gt; map= new HashMap&lt;&gt;();          //添加元素          //put方法的细节          //添加/覆盖          //在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中          //在添加数据时候，如果键存在，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回          map.put(&quot;cai&quot;,&quot;ss&quot;);          map.put(&quot;ss&quot;,&quot;cai&quot;);          System.out.println(map);              //删除          map.remove(&quot;ss&quot;);          System.out.println(map);            //判断集合中的键是否存在          System.out.println(map.containsKey(&quot;cai&quot;));          System.out.println(map.containsValue(&quot;ss&quot;));            //判断集合的长度          System.out.println(map.size());                //清空集合          map.clear();          System.out.println(map);          //判读集合是否为空          System.out.println(map.isEmpty());      &#125;    &#125;  </code></pre></li><li><p>HashMap遍历方式</p><ul><li><pre><code>package Day.Api.map;import java.util.*;import java.util.function.BiConsumer;/** * Created with IntelliJ IDEA. * creator: 蔡芳灿 * Date: 2022/10/5 * Time: 21:34 * 需求： */public class MapTestFor &#123;    public static void main(String[] args) &#123;        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;xiao&quot;,&quot;di&quot;);        map.put(&quot;dd&quot;,&quot;cc&quot;);        map.put(&quot;ll&quot;,&quot;jj&quot;);        map.put(&quot;aa&quot;,&quot;bb&quot;);        System.out.println(map);        //        //遍历键找值        Set&lt;String&gt; m = map.keySet();        for (String key : m) &#123;//            System.out.println(key);            String value = map.get(key);//            System.out.println(key+&quot;=&quot;+value);        &#125;        //迭代器遍历        Iterator&lt;String&gt; it = m.iterator();        while (it.hasNext())&#123;            String str = it.next();            String s = map.get(str);//            System.out.println(s);        &#125;        //Lambda表达式遍历        m.forEach(s -&gt; System.out.println(s));        System.out.println(&quot;-------------键值对遍历-----------------&quot;);        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        for (Map.Entry&lt;String, String&gt; stringStringEntry : entrySet) &#123;            System.out.println(stringStringEntry.getKey()+&quot;=&quot;+stringStringEntry.getValue());        &#125;        System.out.println(&quot;----------------Lambda遍历-------------&quot;);        map.forEach(( key, value) -&gt; System.out.println(key+&quot;=&quot;+value));    &#125;&#125;</code></pre></li></ul></li><li><p>HashMap总结</p><ul><li>HashMap底层是哈希表结构</li><li>依赖于hashCode方法和equals方法保证键的唯一</li><li>如果键存储的是自定义对象，需要重写hashCode和equals方法</li><li>如果值存储自定义对象，不需要重写hashCode和equals方法</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go基础</title>
      <link href="/2022/12/16/go/"/>
      <url>/2022/12/16/go/</url>
      
        <content type="html"><![CDATA[<h1 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h1><h2 id="重要原则"><a href="#重要原则" class="headerlink" title="重要原则"></a>重要原则</h2><ul><li><p>不要通过共享内存来通信，通过通信来共享内存</p><p>解释：</p><p>​在传统的并发编程中，常常通过多个线程共享同一个内存空间的方式来实现数据的共享和通信。这种方式虽然在某些情况下能够提高程序的效率，但是也容易出现各种并发问题，例如竞态条件、死锁、数据竞争等。这些问题不仅难以调试，而且会极大地降低程序的可靠性和性能。</p><p>​Go语言采用了一种全新的并发编程模型，即CSP（Communicating Sequential Processes），它将并发通信作为程序的主要构建块，而将共享内存作为一个附属的特性。在这种模型下，不同的并发实体通过发送和接收消息来进行通信，而不是直接读写共享内存。这种方式可以避免大多数并发问题，提高程序的可靠性和可维护性。</p><p>例子：</p><p>​假设有两个并发实体 A 和 B，它们需要共享一个数据结构来进行通信。如果使用共享内存的方式，那么 A 和 B 都需要对这个数据结构进行读写操作，容易造成数据竞争和死锁等问题。而如果使用通信的方式，可以使用一个协程来维护这个数据结构，A 和 B 只需要通过通信的方式向这个协程发送消息，即可完成对数据结构的操作，从而避免了并发问题。</p></li></ul><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><pre><code class="go">#go 网络问题导致或者是访问代理服务器时出现了问题。D:\project\go\hello&gt;go mod tidygo: finding module for package rsc.io/quoteexample/hello imports        rsc.io/quote: module rsc.io/quote: Get &quot;https://proxy.golang.org/rsc.io/quote/@v/list&quot;: dial tcp 172.217.24.113:443: i/o timeout#修改代理服务器go env -w GOPROXY=https://goproxy.cn,direct</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker-django</title>
      <link href="/2022/11/21/docker-django/"/>
      <url>/2022/11/21/docker-django/</url>
      
        <content type="html"><![CDATA[<!-- # docker部署 Django --><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>在根目录创建Dockerfile</p><pre><code>FROM python:3ENV PYTHONUNBUFFERED 1WORKDIR /code/djangoblog/#RUN  apt-get install ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime \ADD requirements.txt requirements.txtRUN pip install --upgrade pip  &amp;&amp; \        pip install -Ur requirements.txt  &amp;&amp; \        pip install gunicorn[gevent] &amp;&amp; \        pip cache purgeEXPOSE 8099ADD . .RUN chmod +x bin/docker_start.shENTRYPOINT [&quot;bin/docker_start.sh&quot;]</code></pre></li><li><p>创建需要的依赖的配置文件</p><pre><code>使用命令行创建pip freeze &gt; requirements.txt pip install -Ur requirements.txt</code></pre></li><li><p>创建在运行脚本</p><pre><code>#!/usr/bin/env bashpython manage.py runserver 0.0.0.0:8099</code></pre></li></ol><h2 id="打包成docker镜像"><a href="#打包成docker镜像" class="headerlink" title="打包成docker镜像"></a>打包成docker镜像</h2><pre><code> docker build -t houses:v0.1 . </code></pre><h2 id="推送和拉取到docker-Hub"><a href="#推送和拉取到docker-Hub" class="headerlink" title="推送和拉取到docker Hub"></a>推送和拉取到docker Hub</h2><pre><code> //设置标签 docker tag houses:v0.1 shanhui/houses:tagname //推送到docker Hub docker push shanhui/houses:tagname  //拉取 docker pull shanhui/houses:houses</code></pre><h2 id="docker运行Django"><a href="#docker运行Django" class="headerlink" title="docker运行Django"></a>docker运行Django</h2><pre><code>docker run -d  -p 8099:8099 3a16afa66aab[images]</code></pre><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><img src="https://gcore.jsdelivr.net/gh/csh1311/blogImage@main/image-20221120200528932.png" alt="image-20221120200528932"></p><pre><code>docker image rmi shanhui/houses:tagname如果还有容器运行会报Error response from daemon: conflict: unable to remove repository reference &quot;shanhui/houses:tagname&quot; (must force) - container 44d9766d8fd6 is using its referenced image 2b18f4236f3e解决办法 如果还有请反复执行 docker stop 44d9766d8fd6 docker rm 44d9766d8fd6 docker image rmi shanhui/houses:tagname</code></pre><!-- <style>  /* 设置整个页面的字体 */  html, body, .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 80px;  } --><!-- </style> -->]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
